// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { MeterProvider, PeriodicExportingMetricReader, } from "@opentelemetry/sdk-metrics";
import { AzureMonitorMetricExporter } from "@azure/monitor-opentelemetry-exporter";
import { SpanKind, ValueType } from "@opentelemetry/api";
import { SemanticAttributes, SemanticResourceAttributes, } from "@opentelemetry/semantic-conventions";
/**
 * Azure Monitor Standard Metrics
 * @internal
 */
export class StandardMetrics {
    /**
     * Initializes a new instance of the StandardMetrics class.
     * @param config - Distro configuration.
     * @param options - Standard Metrics options.
     */
    constructor(config, options) {
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        const meterProviderConfig = {
            resource: this._config.resource,
        };
        this._meterProvider = new MeterProvider(meterProviderConfig);
        this._azureExporter = new AzureMonitorMetricExporter(this._config.azureMonitorExporterConfig);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new PeriodicExportingMetricReader(metricReaderOptions);
        this._meterProvider.addMetricReader(this._metricReader);
        this._meter = this._meterProvider.getMeter("AzureMonitorStandardMetricsMeter");
        this._incomingRequestDurationHistogram = this._meter.createHistogram("azureMonitor.http.requestDuration", {
            valueType: ValueType.DOUBLE,
        });
        this._outgoingRequestDurationHistogram = this._meter.createHistogram("azureMonitor.http.dependencyDuration", {
            valueType: ValueType.DOUBLE,
        });
        this._exceptionsCounter = this._meter.createCounter("azureMonitor.exceptionCount", {
            valueType: ValueType.INT,
        });
        this._tracesCounter = this._meter.createCounter("azureMonitor.traceCount", {
            valueType: ValueType.INT,
        });
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     * Add extra attributes to Span so Ingestion doesn't aggregate the data again
     * @internal
     */
    markSpanAsProcessed(span) {
        if (this._config.enableAutoCollectStandardMetrics) {
            if (span.kind === SpanKind.CLIENT) {
                span.setAttributes({
                    "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')",
                });
            }
            else if (span.kind === SpanKind.SERVER) {
                span.setAttributes({
                    "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')",
                });
            }
        }
    }
    /**
     * Record Span metrics
     * @internal
     */
    recordSpan(span) {
        const durationMs = span.duration[0];
        if (span.kind === SpanKind.SERVER) {
            this._incomingRequestDurationHistogram.record(durationMs, this._getRequestDimensions(span));
        }
        else {
            this._outgoingRequestDurationHistogram.record(durationMs, this._getDependencyDimensions(span));
        }
        if (span.events) {
            span.events.forEach((event) => {
                event.attributes = event.attributes || {};
                if (event.name === "exception") {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Exceptions', Ver:'1.1')";
                    this._exceptionsCounter.add(1, this._getExceptionDimensions(span.resource));
                }
                else {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Traces', Ver:'1.1')";
                    this._tracesCounter.add(1, this._getTraceDimensions(span.resource));
                }
            });
        }
    }
    /**
     * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion
     * @internal
     */
    recordLog(logRecord) {
        if (this._isExceptionTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Exceptions', Ver:'1.1')");
            this._exceptionsCounter.add(1, this._getExceptionDimensions(logRecord.resource));
        }
        else if (this._isTraceTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Traces', Ver:'1.1')");
            this._tracesCounter.add(1, this._getTraceDimensions(logRecord.resource));
        }
    }
    _getRequestDimensions(span) {
        const dimensions = this._getBaseDimensions(span.resource);
        dimensions.metricId = "requests/duration";
        const statusCode = String(span.attributes["http.status_code"]);
        dimensions.requestResultCode = statusCode;
        dimensions.requestSuccess = statusCode === "200" ? "True" : "False";
        return dimensions;
    }
    _getDependencyDimensions(span) {
        const dimensions = this._getBaseDimensions(span.resource);
        dimensions.metricId = "dependencies/duration";
        const statusCode = String(span.attributes["http.status_code"]);
        dimensions.dependencyTarget = this._getDependencyTarget(span.attributes);
        dimensions.dependencyResultCode = statusCode;
        dimensions.dependencyType = "http";
        dimensions.dependencySuccess = statusCode === "200" ? "True" : "False";
        return dimensions;
    }
    _getExceptionDimensions(resource) {
        const dimensions = this._getBaseDimensions(resource);
        dimensions.metricId = "exceptions/count";
        return dimensions;
    }
    _getTraceDimensions(resource) {
        const dimensions = this._getBaseDimensions(resource);
        dimensions.metricId = "traces/count";
        return dimensions;
    }
    _getBaseDimensions(resource) {
        const dimensions = {};
        dimensions.IsAutocollected = "True";
        if (resource) {
            const spanResourceAttributes = resource.attributes;
            const serviceName = spanResourceAttributes[SemanticResourceAttributes.SERVICE_NAME];
            const serviceNamespace = spanResourceAttributes[SemanticResourceAttributes.SERVICE_NAMESPACE];
            if (serviceName) {
                if (serviceNamespace) {
                    dimensions.cloudRoleName = `${serviceNamespace}.${serviceName}`;
                }
                else {
                    dimensions.cloudRoleName = String(serviceName);
                }
            }
            const serviceInstanceId = spanResourceAttributes[SemanticResourceAttributes.SERVICE_INSTANCE_ID];
            dimensions.cloudRoleInstance = String(serviceInstanceId);
        }
        return dimensions;
    }
    _getDependencyTarget(attributes) {
        if (!attributes) {
            return "";
        }
        const peerService = attributes[SemanticAttributes.PEER_SERVICE];
        const httpHost = attributes[SemanticAttributes.HTTP_HOST];
        const httpUrl = attributes[SemanticAttributes.HTTP_URL];
        const netPeerName = attributes[SemanticAttributes.NET_PEER_NAME];
        const netPeerIp = attributes[SemanticAttributes.NET_PEER_IP];
        if (peerService) {
            return String(peerService);
        }
        else if (httpHost) {
            return String(httpHost);
        }
        else if (httpUrl) {
            return String(httpUrl);
        }
        else if (netPeerName) {
            return String(netPeerName);
        }
        else if (netPeerIp) {
            return String(netPeerIp);
        }
        return "";
    }
    _isExceptionTelemetry(logRecord) {
        const baseType = logRecord.attributes["_MS.baseType"];
        // If Application Insights Legacy logs
        if (baseType && baseType === "ExceptionData") {
            return true;
        }
        else if (logRecord.attributes[SemanticAttributes.EXCEPTION_MESSAGE] ||
            logRecord.attributes[SemanticAttributes.EXCEPTION_TYPE]) {
            return true;
        }
        return false;
    }
    _isTraceTelemetry(logRecord) {
        const baseType = logRecord.attributes["_MS.baseType"];
        // If Application Insights Legacy logs
        if (baseType && baseType === "MessageData") {
            return true;
        }
        else if (!logRecord.attributes[SemanticAttributes.EXCEPTION_MESSAGE] &&
            !logRecord.attributes[SemanticAttributes.EXCEPTION_TYPE]) {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=standardMetrics.js.map