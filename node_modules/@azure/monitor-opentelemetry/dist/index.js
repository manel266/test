'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var resources = require('@opentelemetry/resources');
var fs = require('fs');
var path = require('path');
var api = require('@opentelemetry/api');
var os = require('os');
var util = require('util');
var opentelemetryInstrumentationAzureSdk = require('@azure/opentelemetry-instrumentation-azure-sdk');
var monitorOpentelemetryExporter = require('@azure/monitor-opentelemetry-exporter');
var exporterTraceOtlpHttp = require('@opentelemetry/exporter-trace-otlp-http');
var sdkTraceNode = require('@opentelemetry/sdk-trace-node');
var sdkTraceBase = require('@opentelemetry/sdk-trace-base');
var instrumentationHttp = require('@opentelemetry/instrumentation-http');
var instrumentationMongodb = require('@opentelemetry/instrumentation-mongodb');
var instrumentationMysql = require('@opentelemetry/instrumentation-mysql');
var instrumentationPg = require('@opentelemetry/instrumentation-pg');
var instrumentationRedis = require('@opentelemetry/instrumentation-redis');
var instrumentationRedis4 = require('@opentelemetry/instrumentation-redis-4');
var exporterMetricsOtlpHttp = require('@opentelemetry/exporter-metrics-otlp-http');
var sdkMetrics = require('@opentelemetry/sdk-metrics');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var exporterLogsOtlpHttp = require('@opentelemetry/exporter-logs-otlp-http');
var apiLogs = require('@opentelemetry/api-logs');
var sdkLogs = require('@opentelemetry/sdk-logs');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var os__namespace = /*#__PURE__*/_interopNamespace(os);

// Copyright (c) Microsoft Corporation.
const statAsync = util.promisify(fs__namespace.stat);
const lstatAsync = util.promisify(fs__namespace.lstat);
const mkdirAsync = util.promisify(fs__namespace.mkdir);
const accessAsync = util.promisify(fs__namespace.access);
const appendFileAsync = util.promisify(fs__namespace.appendFile);
const writeFileAsync = util.promisify(fs__namespace.writeFile);
const readFileAsync = util.promisify(fs__namespace.readFile);
const readdirAsync = util.promisify(fs__namespace.readdir);
const unlinkAsync = util.promisify(fs__namespace.unlink);
/**
 * Validate directory exists.
 */
const confirmDirExists = async (directory) => {
    try {
        const stats = await lstatAsync(directory);
        if (!stats.isDirectory()) {
            throw new Error("Path existed but was not a directory");
        }
    }
    catch (err) {
        if (err && err.code === "ENOENT") {
            try {
                await mkdirAsync(directory);
            }
            catch (mkdirErr) {
                if (mkdirErr && mkdirErr.code !== "EEXIST") {
                    // Handle race condition by ignoring EEXIST
                    throw mkdirErr;
                }
            }
        }
    }
};
/**
 * Computes the size (in bytes) of a file asynchronously.
 */
const getShallowFileSize = async (filePath) => {
    const fileStats = await statAsync(filePath);
    if (fileStats.isFile()) {
        return fileStats.size;
    }
    return null;
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function ignoreOutgoingRequestHook(request) {
    if (request &&
        request.headers &&
        request.headers["user-agent"] &&
        request.headers["user-agent"].toString().indexOf("azsdk-js-monitor-opentelemetry-exporter") > -1) {
        return true;
    }
    return false;
}

// Copyright (c) Microsoft Corporation.
class InternalAzureLogger {
    constructor() {
        this._TAG = "InternalLogger:";
        this._cleanupTimeOut = 60 * 30 * 1000; // 30 minutes;
        this._fileCleanupTimer = null;
        this._logToFile = false;
        this._logToConsole = true;
        const logDestination = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION; // destination can be one of file, console or file+console
        if (logDestination === "file+console") {
            this._logToFile = true;
        }
        if (logDestination === "file") {
            this._logToFile = true;
            this._logToConsole = false;
        }
        this._maxSizeBytes = 50000;
        this._maxHistory = 1;
        this._logFileName = "applicationinsights.log";
        // If custom path not provided use temp folder, /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        const logFilePath = process.env.APPLICATIONINSIGHTS_LOGDIR;
        if (!logFilePath) {
            this._tempDir = path__namespace.join(os__namespace.tmpdir(), "appInsights-node");
        }
        else {
            if (path__namespace.isAbsolute(logFilePath)) {
                this._tempDir = logFilePath;
            }
            else {
                this._tempDir = path__namespace.join(process.cwd(), logFilePath);
            }
        }
        this._fileFullPath = path__namespace.join(this._tempDir, this._logFileName);
        this._backUpNameFormat = `.${this._logFileName}`; // {currentime}.applicationinsights.log
        if (this._logToFile) {
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setInterval(() => {
                    this._fileCleanupTask();
                }, this._cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    async logMessage(message, ...optionalParams) {
        try {
            const args = message ? [message, ...optionalParams] : optionalParams;
            if (this._logToFile) {
                await this._storeToDisk(args);
            }
            if (this._logToConsole) {
                // eslint-disable-next-line no-console
                console.log(...args);
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to log to file: ${err && err.message}`);
        }
    }
    async _storeToDisk(args) {
        const data = `${args}\r\n`;
        try {
            await confirmDirExists(this._tempDir);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to create directory for log file: ${err && err.message}`);
            return;
        }
        try {
            await accessAsync(this._fileFullPath, fs__namespace.constants.F_OK);
        }
        catch (err) {
            // No file create one
            try {
                await appendFileAsync(this._fileFullPath, data);
            }
            catch (appendError) {
                // eslint-disable-next-line no-console
                console.log(this._TAG, `Failed to put log into file: ${appendError && appendError.message}`);
                return;
            }
        }
        // Check size
        const size = await getShallowFileSize(this._fileFullPath);
        if (size && size > this._maxSizeBytes) {
            await this._createBackupFile(data);
        }
        else {
            await appendFileAsync(this._fileFullPath, data);
        }
    }
    async _createBackupFile(data) {
        try {
            const buffer = await readFileAsync(this._fileFullPath);
            const backupPath = path__namespace.join(this._tempDir, `${new Date().getTime()}.${this._logFileName}`);
            await writeFileAsync(backupPath, buffer);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log("Failed to generate backup log file", err);
        }
        finally {
            // Store logs
            writeFileAsync(this._fileFullPath, data);
        }
    }
    async _fileCleanupTask() {
        try {
            let files = await readdirAsync(this._tempDir);
            // Filter only backup files
            files = files.filter((f) => path__namespace.basename(f).indexOf(this._backUpNameFormat) > -1);
            // Sort by creation date
            files.sort((a, b) => {
                // Check expiration
                const aCreationDate = new Date(parseInt(a.split(this._backUpNameFormat)[0]));
                const bCreationDate = new Date(parseInt(b.split(this._backUpNameFormat)[0]));
                if (aCreationDate < bCreationDate) {
                    return -1;
                }
                else {
                    return 1;
                }
            });
            const totalFiles = files.length;
            for (let i = 0; i < totalFiles - this._maxHistory; i++) {
                const pathToDelete = path__namespace.join(this._tempDir, files[i]);
                await unlinkAsync(pathToDelete);
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to cleanup log files: ${err && err.message}`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
class Logger {
    static getInstance() {
        if (!Logger._instance) {
            Logger._instance = new Logger();
        }
        return Logger._instance;
    }
    constructor() {
        this._TAG = "ApplicationInsights:";
        this._internalLogger = new InternalAzureLogger();
        const envLogLevel = process.env.APPLICATIONINSIGHTS_INSTRUMENTATION_LOGGING_LEVEL;
        this._diagLevel = api.DiagLogLevel.WARN; // Default
        switch (envLogLevel) {
            case "ALL":
                this._diagLevel = api.DiagLogLevel.ALL;
                break;
            case "DEBUG":
                this._diagLevel = api.DiagLogLevel.DEBUG;
                break;
            case "ERROR":
                this._diagLevel = api.DiagLogLevel.ERROR;
                break;
            case "INFO":
                this._diagLevel = api.DiagLogLevel.INFO;
                break;
            case "NONE":
                this._diagLevel = api.DiagLogLevel.NONE;
                break;
            case "VERBOSE":
                this._diagLevel = api.DiagLogLevel.VERBOSE;
                break;
            case "WARN":
                this._diagLevel = api.DiagLogLevel.WARN;
                break;
        }
        this.updateLogLevel(this._diagLevel);
    }
    /**
     * Set the global LogLevel. If a global diag logger is already set, this will override it.
     * @param logLevel - The DiagLogLevel used to filter logs sent to the logger.
     * @param suppressOverrideMessage - Setting that suppress the warning message normally emitted when registering a logger when another logger is already registered.
     */
    updateLogLevel(logLevel, suppressOverrideMessage = true) {
        this._diagLevel = logLevel;
        // Set OpenTelemetry Logger
        api.diag.setLogger(this, {
            logLevel: this._diagLevel,
            suppressOverrideMessage,
        });
    }
    error(message, ...optionalParams) {
        if (this._diagLevel >= api.DiagLogLevel.ERROR) {
            this._internalLogger.logMessage(this._TAG + message, optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this._diagLevel >= api.DiagLogLevel.WARN) {
            this._internalLogger.logMessage(this._TAG + message, optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this._diagLevel >= api.DiagLogLevel.INFO) {
            this._internalLogger.logMessage(this._TAG + message, optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this._diagLevel >= api.DiagLogLevel.DEBUG) {
            this._internalLogger.logMessage(this._TAG + message, optionalParams);
        }
    }
    verbose(message, ...optionalParams) {
        if (this._diagLevel >= api.DiagLogLevel.VERBOSE) {
            this._internalLogger.logMessage(this._TAG + message, optionalParams);
        }
    }
}

// Copyright (c) Microsoft Corporation.
const ENV_CONFIGURATION_FILE = "APPLICATIONINSIGHTS_CONFIGURATION_FILE";
const ENV_CONTENT = "APPLICATIONINSIGHTS_CONFIGURATION_CONTENT";
/**
 * Azure Monitor OpenTelemetry Client Configuration through JSON File
 * @internal
 */
class JsonConfig {
    /** Get Singleton instance */
    static getInstance() {
        if (!JsonConfig._instance) {
            JsonConfig._instance = new JsonConfig();
        }
        return JsonConfig._instance;
    }
    /**
     * Initializes a new instance of the JsonConfig class.
     */
    constructor() {
        this._loadJsonFile();
    }
    _loadJsonFile() {
        let jsonString = "";
        const contentJsonConfig = process.env[ENV_CONTENT];
        // JSON string added directly in env variable
        if (contentJsonConfig) {
            jsonString = contentJsonConfig;
        }
        // JSON file
        else {
            let configFileName = "applicationinsights.json";
            let rootPath = path__namespace.join(__dirname, "../../../"); // Root of folder (__dirname = ../dist-esm/src)
            let tempDir = path__namespace.join(rootPath, configFileName); // default
            let configFile = process.env[ENV_CONFIGURATION_FILE];
            if (configFile) {
                if (path__namespace.isAbsolute(configFile)) {
                    tempDir = configFile;
                }
                else {
                    tempDir = path__namespace.join(rootPath, configFile); // Relative path to applicationinsights folder
                }
            }
            try {
                jsonString = fs__namespace.readFileSync(tempDir, "utf8");
            }
            catch (err) {
                Logger.getInstance().info("Failed to read JSON config file: ", err);
            }
        }
        try {
            const jsonConfig = JSON.parse(jsonString);
            this.azureMonitorExporterConfig = jsonConfig.azureMonitorExporterConfig;
            this.otlpLogExporterConfig = jsonConfig.otlpLogExporterConfig;
            this.otlpMetricExporterConfig = jsonConfig.otlpMetricExporterConfig;
            this.otlpTraceExporterConfig = jsonConfig.otlpTraceExporterConfig;
            this.samplingRatio = jsonConfig.samplingRatio;
            this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance;
            this.enableAutoCollectStandardMetrics = jsonConfig.enableAutoCollectStandardMetrics;
            this.instrumentationOptions = jsonConfig.instrumentationOptions;
        }
        catch (err) {
            Logger.getInstance().info("Missing or invalid JSON config file: ", err);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Client Configuration
 */
class AzureMonitorOpenTelemetryConfig {
    set resource(resource) {
        this._resource = this._resource.merge(resource);
    }
    /**
     *Get OpenTelemetry Resource
     */
    get resource() {
        return this._resource;
    }
    /**
     * Initializes a new instance of the AzureMonitorOpenTelemetryConfig class.
     */
    constructor(options) {
        // Default values
        this.azureMonitorExporterConfig = {};
        this.otlpLogExporterConfig = {};
        this.otlpMetricExporterConfig = {};
        this.otlpTraceExporterConfig = {};
        this.enableAutoCollectPerformance = true;
        this.enableAutoCollectStandardMetrics = true;
        this.samplingRatio = 1;
        this.instrumentationOptions = {
            http: { enabled: true },
            azureSdk: { enabled: false },
            mongoDb: { enabled: false },
            mySql: { enabled: false },
            postgreSql: { enabled: false },
            redis: { enabled: false },
            redis4: { enabled: false },
        };
        this._resource = this._getDefaultResource();
        // Merge JSON configuration file if available
        this._mergeConfig();
        // Check for explicitly passed options when instantiating client
        // This will take precedence over other settings
        if (options) {
            // Merge default with provided options
            this.azureMonitorExporterConfig = Object.assign(this.azureMonitorExporterConfig, options.azureMonitorExporterConfig);
            this.otlpTraceExporterConfig = Object.assign(this.otlpTraceExporterConfig, options.otlpTraceExporterConfig);
            this.otlpMetricExporterConfig = Object.assign(this.otlpMetricExporterConfig, options.otlpMetricExporterConfig);
            this.otlpLogExporterConfig = Object.assign(this.otlpLogExporterConfig, options.otlpLogExporterConfig);
            this.instrumentationOptions = Object.assign(this.instrumentationOptions, options.instrumentationOptions);
            this.resource = Object.assign(this.resource, options.resource);
            this.enableAutoCollectPerformance =
                options.enableAutoCollectPerformance || this.enableAutoCollectPerformance;
            this.enableAutoCollectStandardMetrics =
                options.enableAutoCollectStandardMetrics || this.enableAutoCollectStandardMetrics;
            this.samplingRatio = options.samplingRatio || this.samplingRatio;
        }
    }
    _mergeConfig() {
        try {
            const jsonConfig = JsonConfig.getInstance();
            this.enableAutoCollectPerformance =
                jsonConfig.enableAutoCollectPerformance !== undefined
                    ? jsonConfig.enableAutoCollectPerformance
                    : this.enableAutoCollectPerformance;
            this.enableAutoCollectStandardMetrics =
                jsonConfig.enableAutoCollectStandardMetrics !== undefined
                    ? jsonConfig.enableAutoCollectStandardMetrics
                    : this.enableAutoCollectStandardMetrics;
            this.samplingRatio =
                jsonConfig.samplingRatio !== undefined ? jsonConfig.samplingRatio : this.samplingRatio;
            this.azureMonitorExporterConfig = Object.assign(this.azureMonitorExporterConfig, jsonConfig.azureMonitorExporterConfig);
            this.otlpTraceExporterConfig = Object.assign(this.otlpTraceExporterConfig, jsonConfig.otlpTraceExporterConfig);
            this.otlpMetricExporterConfig = Object.assign(this.otlpMetricExporterConfig, jsonConfig.otlpMetricExporterConfig);
            this.otlpLogExporterConfig = Object.assign(this.otlpLogExporterConfig, jsonConfig.otlpLogExporterConfig);
            this.instrumentationOptions = Object.assign(this.instrumentationOptions, jsonConfig.instrumentationOptions);
        }
        catch (error) {
            Logger.getInstance().error("Failed to load JSON config file values.", error);
        }
    }
    _getDefaultResource() {
        let resource = resources.Resource.default();
        // Load resource attributes from env
        const detectResourceConfig = {
            detectors: [resources.envDetectorSync],
        };
        const envResource = resources.detectResourcesSync(detectResourceConfig);
        resource = resource.merge(envResource);
        return resource;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var StandardMetricNames;
(function (StandardMetricNames) {
    StandardMetricNames["HTTP_REQUEST_DURATION"] = "azureMonitor.http.requestDuration";
    StandardMetricNames["HTTP_DEPENDENCY_DURATION"] = "azureMonitor.http.dependencyDuration";
    StandardMetricNames["EXCEPTION_COUNT"] = "azureMonitor.exceptionCount";
    StandardMetricNames["TRACE_COUNT"] = "azureMonitor.traceCount";
})(StandardMetricNames || (StandardMetricNames = {}));
var PerformanceCounterMetricNames;
(function (PerformanceCounterMetricNames) {
    PerformanceCounterMetricNames["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    PerformanceCounterMetricNames["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    PerformanceCounterMetricNames["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    PerformanceCounterMetricNames["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    PerformanceCounterMetricNames["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    PerformanceCounterMetricNames["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(PerformanceCounterMetricNames || (PerformanceCounterMetricNames = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor Performance Counter Metrics
 * @internal
 */
class PerformanceCounterMetrics {
    /**
     * Initializes a new instance of the PerformanceCounterMetrics class.
     * @param config - Distro configuration.
     * @param options - Performance Counters options.
     */
    constructor(config, options) {
        this._collectionInterval = 60000; // 60 seconds
        this._totalCount = 0;
        this._intervalExecutionTime = 0;
        this._config = config;
        this._lastCpus = os__namespace.cpus();
        this._lastCpusProcess = os__namespace.cpus();
        this._lastAppCpuUsage = process.cpuUsage();
        this._lastHrtime = process.hrtime();
        this._lastRequestRate = {
            count: this._totalCount,
            time: +new Date(),
            executionInterval: this._intervalExecutionTime,
        };
        const meterProviderConfig = {
            resource: this._config.resource,
        };
        this._meterProvider = new sdkMetrics.MeterProvider(meterProviderConfig);
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorMetricExporter(this._config.azureMonitorExporterConfig);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdkMetrics.PeriodicExportingMetricReader(metricReaderOptions);
        this._meterProvider.addMetricReader(this._metricReader);
        this._meter = this._meterProvider.getMeter("AzureMonitorPerformanceCountersMeter");
        this._lastRequestRate = { count: 0, time: 0, executionInterval: 0 };
        // Create Instruments
        this._requestDurationHistogram = this._meter.createHistogram(PerformanceCounterMetricNames.REQUEST_DURATION, { valueType: api.ValueType.DOUBLE });
        this._requestRateGauge = this._meter.createObservableGauge(PerformanceCounterMetricNames.REQUEST_RATE, {
            description: "Incoming Requests Average Execution Time",
            valueType: api.ValueType.DOUBLE,
        });
        this._memoryPrivateBytesGauge = this._meter.createObservableGauge(PerformanceCounterMetricNames.PRIVATE_BYTES, { description: "Amount of memory process has used in bytes", valueType: api.ValueType.INT });
        this._memoryAvailableBytesGauge = this._meter.createObservableGauge(PerformanceCounterMetricNames.AVAILABLE_BYTES, { description: "Amount of available memory in bytes", valueType: api.ValueType.INT });
        this._processorTimeGauge = this._meter.createObservableGauge(PerformanceCounterMetricNames.PROCESSOR_TIME, {
            description: "Processor time as a percentage",
            valueType: api.ValueType.DOUBLE,
        });
        this._processTimeGauge = this._meter.createObservableGauge(PerformanceCounterMetricNames.PROCESS_TIME, {
            description: "Process CPU usage as a percentage",
            valueType: api.ValueType.DOUBLE,
        });
        // Add callbacks
        this._requestRateGaugeCallback = this._getRequestRate.bind(this);
        this._memoryPrivateBytesGaugeCallback = this._getPrivateMemory.bind(this);
        this._memoryAvailableBytesGaugeCallback = this._getAvailableMemory.bind(this);
        this._processorTimeGaugeCallback = this._getProcessorTime.bind(this);
        this._processTimeGaugeCallback = this._getProcessTime.bind(this);
        this._memoryPrivateBytesGauge.addCallback(this._memoryPrivateBytesGaugeCallback);
        this._memoryAvailableBytesGauge.addCallback(this._memoryAvailableBytesGaugeCallback);
        this._processTimeGauge.addCallback(this._processTimeGaugeCallback);
        this._processorTimeGauge.addCallback(this._processorTimeGaugeCallback);
        this._requestRateGauge.addCallback(this._requestRateGaugeCallback);
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     * Record Span metrics
     */
    recordSpan(span) {
        if (span.kind !== api.SpanKind.SERVER) {
            return;
        }
        const durationMs = span.duration[0];
        this._requestDurationHistogram.record(durationMs);
        let success = false;
        const statusCode = parseInt(String(span.attributes[semanticConventions.SemanticAttributes.HTTP_STATUS_CODE]));
        if (!isNaN(statusCode)) {
            success = 0 < statusCode && statusCode < 500;
        }
        if (success) {
            this._totalCount++;
        }
        this._intervalExecutionTime += durationMs;
    }
    _getRequestRate(observableResult) {
        const currentTime = +new Date();
        const intervalRequests = this._totalCount - this._lastRequestRate.count || 0;
        const elapsedMs = currentTime - this._lastRequestRate.time;
        if (elapsedMs > 0) {
            const elapsedSeconds = elapsedMs / 1000;
            const requestsPerSec = intervalRequests / elapsedSeconds;
            observableResult.observe(requestsPerSec);
        }
        this._lastRequestRate = {
            count: this._totalCount,
            time: currentTime,
            executionInterval: this._lastRequestRate.executionInterval,
        };
    }
    _getPrivateMemory(observableResult) {
        observableResult.observe(process.memoryUsage().rss);
    }
    _getAvailableMemory(observableResult) {
        observableResult.observe(os__namespace.freemem());
    }
    _getTotalCombinedCpu(cpus, lastCpus) {
        let totalUser = 0;
        let totalSys = 0;
        let totalNice = 0;
        let totalIdle = 0;
        let totalIrq = 0;
        for (let i = 0; !!cpus && i < cpus.length; i++) {
            const cpu = cpus[i];
            const lastCpu = lastCpus[i];
            const times = cpu.times;
            const lastTimes = lastCpu.times;
            // user cpu time (or) % CPU time spent in user space
            let user = times.user - lastTimes.user;
            user = user > 0 ? user : 0; // Avoid negative values
            totalUser += user;
            // system cpu time (or) % CPU time spent in kernel space
            let sys = times.sys - lastTimes.sys;
            sys = sys > 0 ? sys : 0; // Avoid negative values
            totalSys += sys;
            // user nice cpu time (or) % CPU time spent on low priority processes
            let nice = times.nice - lastTimes.nice;
            nice = nice > 0 ? nice : 0; // Avoid negative values
            totalNice += nice;
            // idle cpu time (or) % CPU time spent idle
            let idle = times.idle - lastTimes.idle;
            idle = idle > 0 ? idle : 0; // Avoid negative values
            totalIdle += idle;
            // irq (or) % CPU time spent servicing/handling hardware interrupts
            let irq = times.irq - lastTimes.irq;
            irq = irq > 0 ? irq : 0; // Avoid negative values
            totalIrq += irq;
        }
        const combinedTotal = totalUser + totalSys + totalNice + totalIdle + totalIrq;
        return {
            combinedTotal: combinedTotal,
            totalUser: totalUser,
            totalIdle: totalIdle,
        };
    }
    _getProcessorTime(observableResult) {
        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary
        // to find the delta since the last measurement
        const cpus = os__namespace.cpus();
        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
            const cpuTotals = this._getTotalCombinedCpu(cpus, this._lastCpus);
            const value = cpuTotals.combinedTotal > 0
                ? ((cpuTotals.combinedTotal - cpuTotals.totalIdle) / cpuTotals.combinedTotal) * 100
                : 0;
            observableResult.observe(value);
        }
        this._lastCpus = cpus;
    }
    _getProcessTime(observableResult) {
        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary
        // to find the delta since the last measurement
        const cpus = os__namespace.cpus();
        if (cpus &&
            cpus.length &&
            this._lastCpusProcess &&
            cpus.length === this._lastCpusProcess.length) {
            // Calculate % of total cpu time (user + system) this App Process used (Only supported by node v6.1.0+)
            let appCpuPercent = undefined;
            const appCpuUsage = process.cpuUsage();
            const hrtime = process.hrtime();
            const totalApp = appCpuUsage.user -
                this._lastAppCpuUsage.user +
                (appCpuUsage.system - this._lastAppCpuUsage.system) || 0;
            if (typeof this._lastHrtime !== "undefined" && this._lastHrtime.length === 2) {
                const elapsedTime = (hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3 || 0; // convert to microseconds
                appCpuPercent = (100 * totalApp) / (elapsedTime * cpus.length);
            }
            // Set previous
            this._lastAppCpuUsage = appCpuUsage;
            this._lastHrtime = hrtime;
            const cpuTotals = this._getTotalCombinedCpu(cpus, this._lastCpusProcess);
            const value = appCpuPercent || (cpuTotals.totalUser / cpuTotals.combinedTotal) * 100;
            observableResult.observe(value);
        }
        this._lastCpusProcess = cpus;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor Standard Metrics
 * @internal
 */
class StandardMetrics {
    /**
     * Initializes a new instance of the StandardMetrics class.
     * @param config - Distro configuration.
     * @param options - Standard Metrics options.
     */
    constructor(config, options) {
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        const meterProviderConfig = {
            resource: this._config.resource,
        };
        this._meterProvider = new sdkMetrics.MeterProvider(meterProviderConfig);
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorMetricExporter(this._config.azureMonitorExporterConfig);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdkMetrics.PeriodicExportingMetricReader(metricReaderOptions);
        this._meterProvider.addMetricReader(this._metricReader);
        this._meter = this._meterProvider.getMeter("AzureMonitorStandardMetricsMeter");
        this._incomingRequestDurationHistogram = this._meter.createHistogram("azureMonitor.http.requestDuration", {
            valueType: api.ValueType.DOUBLE,
        });
        this._outgoingRequestDurationHistogram = this._meter.createHistogram("azureMonitor.http.dependencyDuration", {
            valueType: api.ValueType.DOUBLE,
        });
        this._exceptionsCounter = this._meter.createCounter("azureMonitor.exceptionCount", {
            valueType: api.ValueType.INT,
        });
        this._tracesCounter = this._meter.createCounter("azureMonitor.traceCount", {
            valueType: api.ValueType.INT,
        });
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     * Add extra attributes to Span so Ingestion doesn't aggregate the data again
     * @internal
     */
    markSpanAsProcessed(span) {
        if (this._config.enableAutoCollectStandardMetrics) {
            if (span.kind === api.SpanKind.CLIENT) {
                span.setAttributes({
                    "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')",
                });
            }
            else if (span.kind === api.SpanKind.SERVER) {
                span.setAttributes({
                    "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')",
                });
            }
        }
    }
    /**
     * Record Span metrics
     * @internal
     */
    recordSpan(span) {
        const durationMs = span.duration[0];
        if (span.kind === api.SpanKind.SERVER) {
            this._incomingRequestDurationHistogram.record(durationMs, this._getRequestDimensions(span));
        }
        else {
            this._outgoingRequestDurationHistogram.record(durationMs, this._getDependencyDimensions(span));
        }
        if (span.events) {
            span.events.forEach((event) => {
                event.attributes = event.attributes || {};
                if (event.name === "exception") {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Exceptions', Ver:'1.1')";
                    this._exceptionsCounter.add(1, this._getExceptionDimensions(span.resource));
                }
                else {
                    event.attributes["_MS.ProcessedByMetricExtractors"] = "(Name:'Traces', Ver:'1.1')";
                    this._tracesCounter.add(1, this._getTraceDimensions(span.resource));
                }
            });
        }
    }
    /**
     * Record LogRecord metrics, add attribute so data is not aggregated again in ingestion
     * @internal
     */
    recordLog(logRecord) {
        if (this._isExceptionTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Exceptions', Ver:'1.1')");
            this._exceptionsCounter.add(1, this._getExceptionDimensions(logRecord.resource));
        }
        else if (this._isTraceTelemetry(logRecord)) {
            logRecord.setAttribute("_MS.ProcessedByMetricExtractors", "(Name:'Traces', Ver:'1.1')");
            this._tracesCounter.add(1, this._getTraceDimensions(logRecord.resource));
        }
    }
    _getRequestDimensions(span) {
        const dimensions = this._getBaseDimensions(span.resource);
        dimensions.metricId = "requests/duration";
        const statusCode = String(span.attributes["http.status_code"]);
        dimensions.requestResultCode = statusCode;
        dimensions.requestSuccess = statusCode === "200" ? "True" : "False";
        return dimensions;
    }
    _getDependencyDimensions(span) {
        const dimensions = this._getBaseDimensions(span.resource);
        dimensions.metricId = "dependencies/duration";
        const statusCode = String(span.attributes["http.status_code"]);
        dimensions.dependencyTarget = this._getDependencyTarget(span.attributes);
        dimensions.dependencyResultCode = statusCode;
        dimensions.dependencyType = "http";
        dimensions.dependencySuccess = statusCode === "200" ? "True" : "False";
        return dimensions;
    }
    _getExceptionDimensions(resource) {
        const dimensions = this._getBaseDimensions(resource);
        dimensions.metricId = "exceptions/count";
        return dimensions;
    }
    _getTraceDimensions(resource) {
        const dimensions = this._getBaseDimensions(resource);
        dimensions.metricId = "traces/count";
        return dimensions;
    }
    _getBaseDimensions(resource) {
        const dimensions = {};
        dimensions.IsAutocollected = "True";
        if (resource) {
            const spanResourceAttributes = resource.attributes;
            const serviceName = spanResourceAttributes[semanticConventions.SemanticResourceAttributes.SERVICE_NAME];
            const serviceNamespace = spanResourceAttributes[semanticConventions.SemanticResourceAttributes.SERVICE_NAMESPACE];
            if (serviceName) {
                if (serviceNamespace) {
                    dimensions.cloudRoleName = `${serviceNamespace}.${serviceName}`;
                }
                else {
                    dimensions.cloudRoleName = String(serviceName);
                }
            }
            const serviceInstanceId = spanResourceAttributes[semanticConventions.SemanticResourceAttributes.SERVICE_INSTANCE_ID];
            dimensions.cloudRoleInstance = String(serviceInstanceId);
        }
        return dimensions;
    }
    _getDependencyTarget(attributes) {
        if (!attributes) {
            return "";
        }
        const peerService = attributes[semanticConventions.SemanticAttributes.PEER_SERVICE];
        const httpHost = attributes[semanticConventions.SemanticAttributes.HTTP_HOST];
        const httpUrl = attributes[semanticConventions.SemanticAttributes.HTTP_URL];
        const netPeerName = attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME];
        const netPeerIp = attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
        if (peerService) {
            return String(peerService);
        }
        else if (httpHost) {
            return String(httpHost);
        }
        else if (httpUrl) {
            return String(httpUrl);
        }
        else if (netPeerName) {
            return String(netPeerName);
        }
        else if (netPeerIp) {
            return String(netPeerIp);
        }
        return "";
    }
    _isExceptionTelemetry(logRecord) {
        const baseType = logRecord.attributes["_MS.baseType"];
        // If Application Insights Legacy logs
        if (baseType && baseType === "ExceptionData") {
            return true;
        }
        else if (logRecord.attributes[semanticConventions.SemanticAttributes.EXCEPTION_MESSAGE] ||
            logRecord.attributes[semanticConventions.SemanticAttributes.EXCEPTION_TYPE]) {
            return true;
        }
        return false;
    }
    _isTraceTelemetry(logRecord) {
        const baseType = logRecord.attributes["_MS.baseType"];
        // If Application Insights Legacy logs
        if (baseType && baseType === "MessageData") {
            return true;
        }
        else if (!logRecord.attributes[semanticConventions.SemanticAttributes.EXCEPTION_MESSAGE] &&
            !logRecord.attributes[semanticConventions.SemanticAttributes.EXCEPTION_TYPE]) {
            return true;
        }
        return false;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Metric Handler
 */
class MetricHandler {
    /**
     * Initializes a new instance of the MetricHandler class.
     * @param config - Distro configuration.
     * @param options - Metric Handler options.
     */
    constructor(config, options) {
        var _a;
        this._collectionInterval = 60000; // 60 seconds
        this._config = config;
        if (this._config.enableAutoCollectStandardMetrics) {
            this._standardMetrics = new StandardMetrics(this._config);
        }
        if (this._config.enableAutoCollectPerformance) {
            this._perfCounterMetrics = new PerformanceCounterMetrics(this._config);
        }
        const meterProviderConfig = {
            resource: this._config.resource,
        };
        this._meterProvider = new sdkMetrics.MeterProvider(meterProviderConfig);
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorMetricExporter(this._config.azureMonitorExporterConfig);
        let metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdkMetrics.PeriodicExportingMetricReader(metricReaderOptions);
        this._meterProvider.addMetricReader(this._metricReader);
        if ((_a = config.otlpMetricExporterConfig) === null || _a === void 0 ? void 0 : _a.enabled) {
            this._otlpExporter = new exporterMetricsOtlpHttp.OTLPMetricExporter(config.otlpMetricExporterConfig);
            const otlpMetricReader = new sdkMetrics.PeriodicExportingMetricReader({
                exporter: this._otlpExporter,
                exportIntervalMillis: (options === null || options === void 0 ? void 0 : options.collectionInterval) || this._collectionInterval,
            });
            this._meterProvider.addMetricReader(otlpMetricReader);
        }
        api.metrics.setGlobalMeterProvider(this._meterProvider);
        this._meter = this._meterProvider.getMeter("AzureMonitorMeter");
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._meterProvider;
    }
    /**
     *Get OpenTelemetry Meter
     */
    getMeter() {
        return this._meter;
    }
    /**
     *Get OpenTelemetry MeterProvider for standard metrics
     */
    getStandardMetricsMeterProvider() {
        var _a;
        return (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.getMeterProvider();
    }
    /**
     *Get OpenTelemetry MeterProvider for performance counter metrics
     */
    getPerfCountersMeterProvider() {
        var _a;
        return (_a = this._perfCounterMetrics) === null || _a === void 0 ? void 0 : _a.getMeterProvider();
    }
    markSpanAsProcessed(span) {
        var _a;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.markSpanAsProcessed(span);
    }
    recordSpan(span) {
        var _a, _b;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.recordSpan(span);
        (_b = this._perfCounterMetrics) === null || _b === void 0 ? void 0 : _b.recordSpan(span);
    }
    recordLog(logRecord) {
        var _a;
        (_a = this._standardMetrics) === null || _a === void 0 ? void 0 : _a.recordLog(logRecord);
    }
    /**
     * Shutdown handler, all Meter providers will return no-op Meters
     */
    async shutdown() {
        var _a, _b;
        this._meterProvider.shutdown();
        (_a = this._perfCounterMetrics) === null || _a === void 0 ? void 0 : _a.shutdown();
        (_b = this._standardMetrics) === null || _b === void 0 ? void 0 : _b.shutdown();
    }
    /**
     * Force flush all Meter Providers
     */
    async flush() {
        var _a, _b;
        await this._meterProvider.forceFlush();
        await ((_a = this._perfCounterMetrics) === null || _a === void 0 ? void 0 : _a.flush());
        await ((_b = this._standardMetrics) === null || _b === void 0 ? void 0 : _b.flush());
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor Span Processor.
 * @internal
 */
class AzureMonitorSpanProcessor {
    constructor(metricHandler) {
        this._metricHandler = metricHandler;
    }
    forceFlush() {
        return Promise.resolve();
    }
    onStart(span, _context) {
        this._metricHandler.markSpanAsProcessed(span);
    }
    onEnd(span) {
        this._metricHandler.recordSpan(span);
    }
    shutdown() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
class AzureFunctionsHook {
    constructor() {
        try {
            // TODO: Add types files when publicly available
            this._functionsCoreModule = require("@azure/functions-core");
            // Only v3 of Azure Functions library is supported right now. See matrix of versions here:
            // https://github.com/Azure/azure-functions-nodejs-library
            const funcProgModel = this._functionsCoreModule.getProgrammingModel();
            if (funcProgModel.name === "@azure/functions" && funcProgModel.version.startsWith("3.")) {
                this._addPreInvocationHook();
            }
            else {
                Logger.getInstance().debug(`AzureFunctionsHook does not support model "${funcProgModel.name}" version "${funcProgModel.version}"`);
            }
        }
        catch (error) {
            Logger.getInstance().debug("@azure/functions-core failed to load, not running in Azure Functions");
        }
    }
    shutdown() {
        if (this._preInvocationHook) {
            this._preInvocationHook.dispose();
            this._preInvocationHook = undefined;
        }
        this._functionsCoreModule = undefined;
    }
    _addPreInvocationHook() {
        if (!this._preInvocationHook) {
            this._preInvocationHook = this._functionsCoreModule.registerHook("preInvocation", async (preInvocationContext) => {
                const ctx = preInvocationContext.invocationContext;
                // Update context to use Azure Functions one
                let extractedContext = null;
                try {
                    if (ctx.traceContext) {
                        extractedContext = api.propagation.extract(api.ROOT_CONTEXT, ctx.traceContext);
                    }
                    const currentContext = extractedContext || api.context.active();
                    preInvocationContext.functionCallback = api.context.bind(currentContext, preInvocationContext.functionCallback);
                }
                catch (err) {
                    Logger.getInstance().error("Failed to propagate context in Azure Functions", err);
                }
            });
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Trace Handler
 */
class TraceHandler {
    /**
     * Initializes a new instance of the TraceHandler class.
     * @param _config - Configuration.
     * @param _metricHandler - MetricHandler.
     */
    constructor(config, metricHandler) {
        var _a;
        this._config = config;
        this._metricHandler = metricHandler;
        this._instrumentations = [];
        const aiSampler = new monitorOpentelemetryExporter.ApplicationInsightsSampler(this._config.samplingRatio);
        const tracerConfig = {
            sampler: aiSampler,
            resource: this._config.resource,
            forceFlushTimeoutMillis: 30000,
        };
        this._tracerProvider = new sdkTraceNode.NodeTracerProvider(tracerConfig);
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorTraceExporter(this._config.azureMonitorExporterConfig);
        const bufferConfig = {
            maxExportBatchSize: 512,
            scheduledDelayMillis: 5000,
            exportTimeoutMillis: 30000,
            maxQueueSize: 2048,
        };
        this._spanProcessor = new sdkTraceBase.BatchSpanProcessor(this._azureExporter, bufferConfig);
        this._tracerProvider.addSpanProcessor(this._spanProcessor);
        if ((_a = this._config.otlpTraceExporterConfig) === null || _a === void 0 ? void 0 : _a.enabled) {
            this._otlpExporter = new exporterTraceOtlpHttp.OTLPTraceExporter(config.otlpTraceExporterConfig);
            let otlpSpanProcessor = new sdkTraceBase.BatchSpanProcessor(this._otlpExporter, bufferConfig);
            this._tracerProvider.addSpanProcessor(otlpSpanProcessor);
        }
        this._tracerProvider.register();
        this._tracer = this._tracerProvider.getTracer("AzureMonitorTracer");
        const azureSpanProcessor = new AzureMonitorSpanProcessor(this._metricHandler);
        this._tracerProvider.addSpanProcessor(azureSpanProcessor);
        this._azureFunctionsHook = new AzureFunctionsHook();
        this._initializeInstrumentations();
    }
    /**
     *Get OpenTelemetry TracerProvider
     */
    getTracerProvider() {
        return this._tracerProvider;
    }
    /**
     *Get OpenTelemetry Tracer
     */
    getTracer() {
        return this._tracer;
    }
    /**
     * Shutdown handler, all Tracer providers will return no-op Tracers
     */
    async shutdown() {
        await this._tracerProvider.shutdown();
        this._azureFunctionsHook.shutdown();
    }
    /**
     * Force flush Tracer Provider
     */
    async flush() {
        return this._tracerProvider.forceFlush();
    }
    /**
     * Add OpenTelemetry Span Processor
     */
    addSpanProcessor(spanProcessor) {
        this._tracerProvider.addSpanProcessor(spanProcessor);
    }
    /**
     * Add OpenTelemetry Instrumentation, should be called before calling start
     */
    addInstrumentation(instrumentation) {
        if (instrumentation) {
            this._instrumentations.push(instrumentation);
        }
    }
    /**
     * Disable all OpenTelemetry Instrumentations
     */
    disableInstrumentations() {
        this._instrumentations.forEach((instrumentation) => {
            instrumentation.disable();
        });
    }
    /**
     * Start auto collection of telemetry
     */
    _initializeInstrumentations() {
        if (!this._httpInstrumentation) {
            const httpinstrumentationOptions = this._config.instrumentationOptions
                .http;
            const providedIgnoreOutgoingRequestHook = httpinstrumentationOptions.ignoreOutgoingRequestHook;
            const mergedIgnoreOutgoingRequestHook = (request) => {
                const result = ignoreOutgoingRequestHook(request);
                if (!result) {
                    // Not internal call
                    if (providedIgnoreOutgoingRequestHook) {
                        // Provided hook in config
                        return providedIgnoreOutgoingRequestHook(request);
                    }
                }
                return result;
            };
            httpinstrumentationOptions.ignoreOutgoingRequestHook = mergedIgnoreOutgoingRequestHook;
            this._httpInstrumentation = new instrumentationHttp.HttpInstrumentation(this._config.instrumentationOptions.http);
            this.addInstrumentation(this._httpInstrumentation);
        }
        if (!this._azureSdkInstrumentation) {
            this._azureSdkInstrumentation = opentelemetryInstrumentationAzureSdk.createAzureSdkInstrumentation(this._config.instrumentationOptions.azureSdk);
            this.addInstrumentation(this._azureSdkInstrumentation);
        }
        if (!this._mongoDbInstrumentation) {
            this._mongoDbInstrumentation = new instrumentationMongodb.MongoDBInstrumentation(this._config.instrumentationOptions.mongoDb);
            this.addInstrumentation(this._mongoDbInstrumentation);
        }
        if (!this._mySqlInstrumentation) {
            this._mySqlInstrumentation = new instrumentationMysql.MySQLInstrumentation(this._config.instrumentationOptions.mySql);
            this.addInstrumentation(this._mySqlInstrumentation);
        }
        if (!this._postgressInstrumentation) {
            this._postgressInstrumentation = new instrumentationPg.PgInstrumentation(this._config.instrumentationOptions.postgreSql);
            this.addInstrumentation(this._postgressInstrumentation);
        }
        if (!this._redisInstrumentation) {
            this._redisInstrumentation = new instrumentationRedis.RedisInstrumentation(this._config.instrumentationOptions.redis);
            this.addInstrumentation(this._redisInstrumentation);
        }
        if (!this._redis4Instrumentation) {
            this._redis4Instrumentation = new instrumentationRedis4.RedisInstrumentation(this._config.instrumentationOptions.redis4);
            this.addInstrumentation(this._redis4Instrumentation);
        }
        this._instrumentations.forEach((instrumentation) => {
            instrumentation.setTracerProvider(this._tracerProvider);
            instrumentation.setMeterProvider(this._metricHandler.getMeterProvider());
            if (instrumentation.getConfig().enabled) {
                instrumentation.enable();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor LogRecord Processor.
 * @internal
 */
class AzureLogRecordProcessor {
    constructor(metricHandler) {
        this._metricHandler = metricHandler;
    }
    onEmit(logRecord) {
        this._metricHandler.recordLog(logRecord);
    }
    forceFlush() {
        return Promise.resolve();
    }
    shutdown() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Log Handler
 */
class LogHandler {
    /**
     * Initializes a new instance of the TraceHandler class.
     * @param _config - Distro configuration.
     * @param _metricHandler - MetricHandler.
     */
    constructor(config, metricHandler) {
        var _a;
        this._config = config;
        this._metricHandler = metricHandler;
        const loggerProviderConfig = {
            resource: this._config.resource,
        };
        this._loggerProvider = new sdkLogs.LoggerProvider(loggerProviderConfig);
        this._azureExporter = new monitorOpentelemetryExporter.AzureMonitorLogExporter(this._config.azureMonitorExporterConfig);
        // Log Processor could be configured through env variables
        // https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/#batch-logrecord-processor
        this._logRecordProcessor = new sdkLogs.BatchLogRecordProcessor(this._azureExporter);
        this._loggerProvider.addLogRecordProcessor(this._logRecordProcessor);
        this._azureLogProccessor = new AzureLogRecordProcessor(this._metricHandler);
        this._loggerProvider.addLogRecordProcessor(this._azureLogProccessor);
        if ((_a = config.otlpLogExporterConfig) === null || _a === void 0 ? void 0 : _a.enabled) {
            this._otlpExporter = new exporterLogsOtlpHttp.OTLPLogExporter(config.otlpLogExporterConfig);
            const otlpLogProcessor = new sdkLogs.BatchLogRecordProcessor(this._otlpExporter);
            this._loggerProvider.addLogRecordProcessor(otlpLogProcessor);
        }
        apiLogs.logs.setGlobalLoggerProvider(this._loggerProvider);
        this._logger = this._loggerProvider.getLogger("AzureMonitorLogger", undefined);
    }
    /**
     *Get OpenTelemetry LoggerProvider
     */
    getLoggerProvider() {
        return this._loggerProvider;
    }
    /**
     *Get OpenTelemetry Logger
     */
    getLogger() {
        return this._logger;
    }
    /**
     * Shutdown handler, all Logger providers will return no-op Loggers
     */
    async shutdown() {
        await this._loggerProvider.shutdown();
    }
    /**
     * Force flush Logger Provider
     */
    async flush() {
        return this._loggerProvider.forceFlush();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const AZURE_MONITOR_STATSBEAT_FEATURES = "AZURE_MONITOR_STATSBEAT_FEATURES";
var StatsbeatFeature;
(function (StatsbeatFeature) {
    StatsbeatFeature[StatsbeatFeature["DISK_RETRY"] = 0] = "DISK_RETRY";
    StatsbeatFeature[StatsbeatFeature["AAD_HANDLING"] = 1] = "AAD_HANDLING";
    StatsbeatFeature[StatsbeatFeature["WEB_SNIPPET"] = 2] = "WEB_SNIPPET";
    StatsbeatFeature[StatsbeatFeature["DISTRO"] = 4] = "DISTRO";
})(StatsbeatFeature || (StatsbeatFeature = {}));
var StatsbeatInstrumentation;
(function (StatsbeatInstrumentation) {
    StatsbeatInstrumentation[StatsbeatInstrumentation["AZURE_CORE_TRACING"] = 0] = "AZURE_CORE_TRACING";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MONGODB"] = 1] = "MONGODB";
    StatsbeatInstrumentation[StatsbeatInstrumentation["MYSQL"] = 2] = "MYSQL";
    StatsbeatInstrumentation[StatsbeatInstrumentation["REDIS"] = 4] = "REDIS";
    StatsbeatInstrumentation[StatsbeatInstrumentation["POSTGRES"] = 8] = "POSTGRES";
})(StatsbeatInstrumentation || (StatsbeatInstrumentation = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Client
 */
class AzureMonitorOpenTelemetryClient {
    /**
     * Initializes a new instance of the AzureMonitorOpenTelemetryClient class.
     * @param options Azure Monitor OpenTelemetry Options
     */
    constructor(options) {
        this._config = new AzureMonitorOpenTelemetryConfig(options);
        this._setStatsbeatFeatures();
        this._metricHandler = new MetricHandler(this._config);
        this._traceHandler = new TraceHandler(this._config, this._metricHandler);
        this._logHandler = new LogHandler(this._config, this._metricHandler);
    }
    /**
     *Get OpenTelemetry TracerProvider
     */
    getTracerProvider() {
        return this._traceHandler.getTracerProvider();
    }
    /**
     *Get OpenTelemetry TracerProvider
     */
    getTracer() {
        return this._traceHandler.getTracer();
    }
    /**
     *Get OpenTelemetry MeterProvider
     */
    getMeterProvider() {
        return this._metricHandler.getMeterProvider();
    }
    /**
     *Get OpenTelemetry Meter
     */
    getMeter() {
        return this._metricHandler.getMeter();
    }
    /**
     *Get OpenTelemetry LoggerProvider
     */
    getLoggerProvider() {
        return this._logHandler.getLoggerProvider();
    }
    /**
     *Get OpenTelemetry Logger
     */
    getLogger() {
        return this._logHandler.getLogger();
    }
    /**
     *Try to send all queued telemetry if present.
     */
    async flush() {
        try {
            await this._traceHandler.flush();
            await this._metricHandler.flush();
            await this._logHandler.flush();
        }
        catch (err) {
            Logger.getInstance().error("Failed to flush telemetry", err);
        }
    }
    /**
     *Shutdown all handlers
     */
    async shutdown() {
        this._traceHandler.shutdown();
        this._metricHandler.shutdown();
        this._logHandler.shutdown();
    }
    _setStatsbeatFeatures() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        let instrumentationBitMap = 0;
        if ((_b = (_a = this._config.instrumentationOptions) === null || _a === void 0 ? void 0 : _a.azureSdk) === null || _b === void 0 ? void 0 : _b.enabled) {
            instrumentationBitMap |= StatsbeatInstrumentation.AZURE_CORE_TRACING;
        }
        if ((_d = (_c = this._config.instrumentationOptions) === null || _c === void 0 ? void 0 : _c.mongoDb) === null || _d === void 0 ? void 0 : _d.enabled) {
            instrumentationBitMap |= StatsbeatInstrumentation.MONGODB;
        }
        if ((_f = (_e = this._config.instrumentationOptions) === null || _e === void 0 ? void 0 : _e.mySql) === null || _f === void 0 ? void 0 : _f.enabled) {
            instrumentationBitMap |= StatsbeatInstrumentation.MYSQL;
        }
        if ((_h = (_g = this._config.instrumentationOptions) === null || _g === void 0 ? void 0 : _g.postgreSql) === null || _h === void 0 ? void 0 : _h.enabled) {
            instrumentationBitMap |= StatsbeatInstrumentation.POSTGRES;
        }
        if ((_k = (_j = this._config.instrumentationOptions) === null || _j === void 0 ? void 0 : _j.redis) === null || _k === void 0 ? void 0 : _k.enabled) {
            instrumentationBitMap |= StatsbeatInstrumentation.REDIS;
        }
        let featureBitMap = 0;
        featureBitMap |= StatsbeatFeature.DISTRO;
        try {
            process.env[AZURE_MONITOR_STATSBEAT_FEATURES] = JSON.stringify({
                instrumentation: instrumentationBitMap,
                feature: featureBitMap,
            });
        }
        catch (error) {
            Logger.getInstance().error("Failed call to JSON.stringify.", error);
        }
    }
}

exports.AzureMonitorOpenTelemetryClient = AzureMonitorOpenTelemetryClient;
//# sourceMappingURL=index.js.map
