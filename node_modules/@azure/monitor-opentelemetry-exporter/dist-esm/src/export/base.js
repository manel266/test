// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { diag } from "@opentelemetry/api";
import { ExportResultCode } from "@opentelemetry/core";
import { ConnectionStringParser } from "../utils/connectionStringParser";
import { HttpSender, FileSystemPersist } from "../platform";
import { isRetriable } from "../utils/breezeUtils";
import { DEFAULT_BREEZE_ENDPOINT, ENV_CONNECTION_STRING, ENV_DISABLE_STATSBEAT, } from "../Declarations/Constants";
import { NetworkStatsbeatMetrics } from "./statsbeat/networkStatsbeatMetrics";
import { MAX_STATSBEAT_FAILURES } from "./statsbeat/types";
import { getInstance } from "./statsbeat/longIntervalStatsbeatMetrics";
const DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS = 60000;
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
export class AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorBaseExporter class.
     * @param AzureMonitorExporterOptions - Exporter configuration.
     */
    constructor(options = {}, isStatsbeatExporter) {
        var _a;
        /**
         * Instrumentation key to be used for exported envelopes
         */
        this._instrumentationKey = "";
        this._endpointUrl = "";
        this._statsbeatFailureCount = 0;
        this._batchSendRetryIntervalMs = DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS;
        this._options = options;
        this._numConsecutiveRedirects = 0;
        this._instrumentationKey = "";
        this._endpointUrl = DEFAULT_BREEZE_ENDPOINT;
        const connectionString = this._options.connectionString || process.env[ENV_CONNECTION_STRING];
        this._isStatsbeatExporter = isStatsbeatExporter ? isStatsbeatExporter : false;
        if (connectionString) {
            const parsedConnectionString = ConnectionStringParser.parse(connectionString);
            this._instrumentationKey =
                parsedConnectionString.instrumentationkey || this._instrumentationKey;
            this._endpointUrl = ((_a = parsedConnectionString.ingestionendpoint) === null || _a === void 0 ? void 0 : _a.trim()) || this._endpointUrl;
        }
        // Instrumentation key is required
        if (!this._instrumentationKey) {
            const message = "No instrumentation key or connection string was provided to the Azure Monitor Exporter";
            diag.error(message);
            throw new Error(message);
        }
        this._sender = new HttpSender(this._endpointUrl, this._options);
        this._persister = new FileSystemPersist(this._instrumentationKey, this._options);
        if (!this._isStatsbeatExporter && !process.env[ENV_DISABLE_STATSBEAT]) {
            // Initialize statsbeatMetrics
            this._networkStatsbeatMetrics = new NetworkStatsbeatMetrics({
                instrumentationKey: this._instrumentationKey,
                endpointUrl: this._endpointUrl,
            });
            this._longIntervalStatsbeatMetrics = getInstance({
                instrumentationKey: this._instrumentationKey,
                endpointUrl: this._endpointUrl,
            });
        }
        this._retryTimer = null;
        diag.debug("AzureMonitorExporter was successfully setup");
    }
    /**
     * Persist envelopes to disk
     */
    async _persist(envelopes) {
        try {
            const success = await this._persister.push(envelopes);
            return success
                ? { code: ExportResultCode.SUCCESS }
                : {
                    code: ExportResultCode.FAILED,
                    error: new Error("Failed to persist envelope in disk."),
                };
        }
        catch (ex) {
            return { code: ExportResultCode.FAILED, error: ex };
        }
    }
    /**
     * Shutdown exporter
     */
    async _shutdown() {
        return this._sender.shutdown();
    }
    /**
     * Export envelopes
     */
    async _exportEnvelopes(envelopes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        diag.info(`Exporting ${envelopes.length} envelope(s)`);
        if (envelopes.length < 1) {
            return { code: ExportResultCode.SUCCESS };
        }
        try {
            const startTime = new Date().getTime();
            const { result, statusCode } = await this._sender.send(envelopes);
            const endTime = new Date().getTime();
            const duration = endTime - startTime;
            this._numConsecutiveRedirects = 0;
            if (statusCode === 200) {
                // Success -- @todo: start retry timer
                if (!this._retryTimer) {
                    this._retryTimer = setTimeout(() => {
                        this._retryTimer = null;
                        this._sendFirstPersistedFile();
                    }, this._batchSendRetryIntervalMs);
                    this._retryTimer.unref();
                }
                // If we are not exportings statsbeat and statsbeat is not disabled -- count success
                (_a = this._networkStatsbeatMetrics) === null || _a === void 0 ? void 0 : _a.countSuccess(duration);
                return { code: ExportResultCode.SUCCESS };
            }
            else if (statusCode && isRetriable(statusCode)) {
                // Failed -- persist failed data
                if (statusCode === 429 || statusCode === 439) {
                    (_b = this._networkStatsbeatMetrics) === null || _b === void 0 ? void 0 : _b.countThrottle(statusCode);
                }
                if (result) {
                    diag.info(result);
                    const breezeResponse = JSON.parse(result);
                    const filteredEnvelopes = [];
                    if (breezeResponse.errors) {
                        breezeResponse.errors.forEach((error) => {
                            if (error.statusCode && isRetriable(error.statusCode)) {
                                filteredEnvelopes.push(envelopes[error.index]);
                            }
                        });
                    }
                    if (filteredEnvelopes.length > 0) {
                        (_c = this._networkStatsbeatMetrics) === null || _c === void 0 ? void 0 : _c.countRetry(statusCode);
                        // calls resultCallback(ExportResult) based on result of persister.push
                        return await this._persist(filteredEnvelopes);
                    }
                    // Failed -- not retriable
                    (_d = this._networkStatsbeatMetrics) === null || _d === void 0 ? void 0 : _d.countFailure(duration, statusCode);
                    return {
                        code: ExportResultCode.FAILED,
                    };
                }
                else {
                    // calls resultCallback(ExportResult) based on result of persister.push
                    (_e = this._networkStatsbeatMetrics) === null || _e === void 0 ? void 0 : _e.countRetry(statusCode);
                    return await this._persist(envelopes);
                }
            }
            else {
                // Failed -- not retriable
                if (this._networkStatsbeatMetrics) {
                    if (statusCode) {
                        this._networkStatsbeatMetrics.countFailure(duration, statusCode);
                    }
                }
                else {
                    this._incrementStatsbeatFailure();
                }
                return {
                    code: ExportResultCode.FAILED,
                };
            }
        }
        catch (error) {
            const restError = error;
            if (restError.statusCode &&
                (restError.statusCode === 307 || // Temporary redirect
                    restError.statusCode === 308)) {
                // Permanent redirect
                this._numConsecutiveRedirects++;
                // To prevent circular redirects
                if (this._numConsecutiveRedirects < 10) {
                    if (restError.response && restError.response.headers) {
                        const location = restError.response.headers.get("location");
                        if (location) {
                            // Update sender URL
                            this._sender.handlePermanentRedirect(location);
                            // Send to redirect endpoint as HTTPs library doesn't handle redirect automatically
                            return this._exportEnvelopes(envelopes);
                        }
                    }
                }
                else {
                    let redirectError = new Error("Circular redirect");
                    (_f = this._networkStatsbeatMetrics) === null || _f === void 0 ? void 0 : _f.countException(redirectError);
                    return { code: ExportResultCode.FAILED, error: redirectError };
                }
            }
            else if (restError.statusCode && isRetriable(restError.statusCode)) {
                (_g = this._networkStatsbeatMetrics) === null || _g === void 0 ? void 0 : _g.countRetry(restError.statusCode);
                return await this._persist(envelopes);
            }
            if (this._isNetworkError(restError)) {
                if (restError.statusCode) {
                    (_h = this._networkStatsbeatMetrics) === null || _h === void 0 ? void 0 : _h.countRetry(restError.statusCode);
                }
                diag.error("Retrying due to transient client side error. Error message:", restError.message);
                return await this._persist(envelopes);
            }
            (_j = this._networkStatsbeatMetrics) === null || _j === void 0 ? void 0 : _j.countException(restError);
            diag.error("Envelopes could not be exported and are not retriable. Error message:", restError.message);
            return { code: ExportResultCode.FAILED, error: restError };
        }
    }
    // Disable collection of statsbeat metrics after max failures
    _incrementStatsbeatFailure() {
        var _a, _b;
        this._statsbeatFailureCount++;
        if (this._statsbeatFailureCount > MAX_STATSBEAT_FAILURES) {
            this._isStatsbeatExporter = false;
            (_a = this._networkStatsbeatMetrics) === null || _a === void 0 ? void 0 : _a.shutdown();
            (_b = this._longIntervalStatsbeatMetrics) === null || _b === void 0 ? void 0 : _b.shutdown();
            this._networkStatsbeatMetrics = undefined;
            this._statsbeatFailureCount = 0;
        }
    }
    async _sendFirstPersistedFile() {
        try {
            const envelopes = (await this._persister.shift());
            if (envelopes) {
                await this._sender.send(envelopes);
            }
        }
        catch (err) {
            diag.warn(`Failed to fetch persisted file`, err);
        }
    }
    _isNetworkError(error) {
        if (error && error.code && error.code === "REQUEST_SEND_ERROR") {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=base.js.map