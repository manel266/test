// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { diag, } from "@opentelemetry/api";
import { MeterProvider, PeriodicExportingMetricReader, } from "@opentelemetry/sdk-metrics";
import { AzureMonitorStatsbeatExporter } from "../../index";
import * as ai from "../../utils/constants/applicationinsights";
import { StatsbeatMetrics } from "./statsbeatMetrics";
import { StatsbeatCounter, STATSBEAT_LANGUAGE, NetworkStatsbeat, } from "./types";
export class NetworkStatsbeatMetrics extends StatsbeatMetrics {
    constructor(options) {
        super();
        this._isInitialized = false;
        this._statsCollectionShortInterval = 900000; // 15 minutes
        this._networkStatsbeatCollection = [];
        this._attach = "sdk";
        this._connectionString = super._getConnectionString(options.endpointUrl);
        this._networkStatsbeatMeterProvider = new MeterProvider();
        const exporterConfig = {
            connectionString: this._connectionString,
        };
        this._networkAzureExporter = new AzureMonitorStatsbeatExporter(exporterConfig);
        // Exports Network Statsbeat every 15 minutes
        const networkMetricReaderOptions = {
            exporter: this._networkAzureExporter,
            exportIntervalMillis: options.networkCollectionInterval || this._statsCollectionShortInterval, // 15 minutes
        };
        this._networkMetricReader = new PeriodicExportingMetricReader(networkMetricReaderOptions);
        this._networkStatsbeatMeterProvider.addMetricReader(this._networkMetricReader);
        this._networkStatsbeatMeter = this._networkStatsbeatMeterProvider.getMeter("Azure Monitor Network Statsbeat");
        this._endpointUrl = options.endpointUrl;
        this._runtimeVersion = process.version;
        this._language = STATSBEAT_LANGUAGE;
        this._version = ai.packageVersion;
        this._host = this._getShortHost(options.endpointUrl);
        this._cikey = options.instrumentationKey;
        this._successCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.SUCCESS_COUNT);
        this._failureCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.FAILURE_COUNT);
        this._retryCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.RETRY_COUNT);
        this._throttleCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.THROTTLE_COUNT);
        this._exceptionCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.EXCEPTION_COUNT);
        this._averageDurationGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.AVERAGE_DURATION);
        this._commonProperties = {
            os: super._os,
            rp: super._resourceProvider,
            cikey: this._cikey,
            runtimeVersion: this._runtimeVersion,
            language: this._language,
            version: this._version,
            attach: this._attach,
        };
        this._networkProperties = {
            endpoint: this._endpointUrl,
            host: this._host,
        };
        this._isInitialized = true;
        this._initialize();
    }
    isInitialized() {
        return this._isInitialized;
    }
    shutdown() {
        this._networkStatsbeatMeterProvider.shutdown();
    }
    async _initialize() {
        try {
            await super._getResourceProvider();
            // Add network observable callbacks
            this._successCountGauge.addCallback(this._successCallback.bind(this));
            this._networkStatsbeatMeter.addBatchObservableCallback(this._failureCallback.bind(this), [
                this._failureCountGauge,
            ]);
            this._networkStatsbeatMeter.addBatchObservableCallback(this._retryCallback.bind(this), [
                this._retryCountGauge,
            ]);
            this._networkStatsbeatMeter.addBatchObservableCallback(this._throttleCallback.bind(this), [
                this._throttleCountGauge,
            ]);
            this._networkStatsbeatMeter.addBatchObservableCallback(this._exceptionCallback.bind(this), [
                this._exceptionCountGauge,
            ]);
            this._averageDurationGauge.addCallback(this._durationCallback.bind(this));
        }
        catch (error) {
            diag.debug("Call to get the resource provider failed.");
        }
    }
    // Observable gauge callbacks
    _successCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign({}, this._commonProperties), this._networkProperties);
        observableResult.observe(counter.totalSuccesfulRequestCount, attributes);
        counter.totalSuccesfulRequestCount = 0;
    }
    _failureCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        /*
          Takes the failureCountGauge, value (of the counter), and attributes
          create a unqiue counter based on statusCode as well
          append statusCode to attributes so the newly created attributes are unique.
        */
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { statusCode: 0 });
        // For each { statusCode -> count } mapping, call observe, passing the count and attributes that include the statusCode
        for (let i = 0; i < counter.totalFailedRequestCount.length; i++) {
            attributes.statusCode = counter.totalFailedRequestCount[i].statusCode;
            observableResult.observe(this._failureCountGauge, counter.totalFailedRequestCount[i].count, Object.assign({}, attributes));
            counter.totalFailedRequestCount[i].count = 0;
        }
    }
    _retryCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { statusCode: 0 });
        for (let i = 0; i < counter.retryCount.length; i++) {
            attributes.statusCode = counter.retryCount[i].statusCode;
            observableResult.observe(this._retryCountGauge, counter.retryCount[i].count, Object.assign({}, attributes));
            counter.retryCount[i].count = 0;
        }
    }
    _throttleCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { statusCode: 0 });
        for (let i = 0; i < counter.throttleCount.length; i++) {
            attributes.statusCode = counter.throttleCount[i].statusCode;
            observableResult.observe(this._throttleCountGauge, counter.throttleCount[i].count, Object.assign({}, attributes));
            counter.throttleCount[i].count = 0;
        }
    }
    _exceptionCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { exceptionType: "" });
        for (let i = 0; i < counter.exceptionCount.length; i++) {
            attributes.exceptionType = counter.exceptionCount[i].exceptionType;
            observableResult.observe(this._exceptionCountGauge, counter.exceptionCount[i].count, Object.assign({}, attributes));
            counter.exceptionCount[i].count = 0;
        }
    }
    _durationCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign({}, this._networkProperties), this._commonProperties);
        for (let i = 0; i < this._networkStatsbeatCollection.length; i++) {
            let currentCounter = this._networkStatsbeatCollection[i];
            currentCounter.time = Number(new Date());
            let intervalRequests = currentCounter.totalRequestCount - currentCounter.lastRequestCount || 0;
            currentCounter.averageRequestExecutionTime =
                (currentCounter.intervalRequestExecutionTime -
                    currentCounter.lastIntervalRequestExecutionTime) /
                    intervalRequests || 0;
            currentCounter.lastIntervalRequestExecutionTime = currentCounter.intervalRequestExecutionTime; // reset
            currentCounter.lastRequestCount = currentCounter.totalRequestCount;
            currentCounter.lastTime = currentCounter.time;
        }
        observableResult.observe(counter.averageRequestExecutionTime, attributes);
        counter.averageRequestExecutionTime = 0;
    }
    // Public methods to increase counters
    countSuccess(duration) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        counter.totalRequestCount++;
        counter.totalSuccesfulRequestCount++;
        counter.intervalRequestExecutionTime += duration;
    }
    countFailure(duration, statusCode) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentStatusCounter = counter.totalFailedRequestCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.totalFailedRequestCount.push({ statusCode: statusCode, count: 1 });
        }
        counter.totalRequestCount++;
        counter.intervalRequestExecutionTime += duration;
    }
    countRetry(statusCode) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentStatusCounter = counter.retryCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.retryCount.push({ statusCode: statusCode, count: 1 });
        }
    }
    countThrottle(statusCode) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentStatusCounter = counter.throttleCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.throttleCount.push({ statusCode: statusCode, count: 1 });
        }
    }
    countException(exceptionType) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentErrorCounter = counter.exceptionCount.find((exceptionCounter) => exceptionType.name === exceptionCounter.exceptionType);
        if (currentErrorCounter) {
            currentErrorCounter.count++;
        }
        else {
            counter.exceptionCount.push({ exceptionType: exceptionType.name, count: 1 });
        }
    }
    // Gets a networkStatsbeat counter if one exists for the given endpoint
    _getNetworkStatsbeatCounter(endpoint, host) {
        // Check if the counter is available
        for (let i = 0; i < this._networkStatsbeatCollection.length; i++) {
            // Same object
            if (endpoint === this._networkStatsbeatCollection[i].endpoint &&
                host === this._networkStatsbeatCollection[i].host) {
                return this._networkStatsbeatCollection[i];
            }
        }
        // Create a new counter if not found
        let newCounter = new NetworkStatsbeat(endpoint, host);
        this._networkStatsbeatCollection.push(newCounter);
        return newCounter;
    }
    _getShortHost(originalHost) {
        let shortHost = originalHost;
        try {
            let hostRegex = new RegExp(/^https?:\/\/(?:www\.)?([^\/.-]+)/);
            let res = hostRegex.exec(originalHost);
            if (res != null && res.length > 1) {
                shortHost = res[1];
            }
            shortHost = shortHost.replace(".in.applicationinsights.azure.com", "");
        }
        catch (error) {
            diag.debug("Failed to get the short host name.");
        }
        return shortHost;
    }
}
//# sourceMappingURL=networkStatsbeatMetrics.js.map