// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { DataPointType } from "@opentelemetry/sdk-metrics";
import { createTagsFromResource } from "./common";
function createPropertiesFromMetricAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            properties[key] = attributes[key];
        }
    }
    return properties;
}
/**
 * Metric to Azure envelope parsing.
 * @internal
 */
export function resourceMetricsToEnvelope(metrics, ikey, isStatsbeat) {
    let envelopes = [];
    const time = new Date();
    const instrumentationKey = ikey;
    const tags = createTagsFromResource(metrics.resource);
    let envelopeName;
    if (isStatsbeat) {
        envelopeName = "Microsoft.ApplicationInsights.Statsbeat";
    }
    else {
        envelopeName = "Microsoft.ApplicationInsights.Metric";
    }
    metrics.scopeMetrics.forEach((scopeMetric) => {
        scopeMetric.metrics.forEach((metric) => {
            metric.dataPoints.forEach((dataPoint) => {
                let baseData = {
                    metrics: [],
                    version: 2,
                    properties: {},
                };
                baseData.properties = createPropertiesFromMetricAttributes(dataPoint.attributes);
                var metricDataPoint = {
                    name: metric.descriptor.name,
                    value: 0,
                    dataPointType: "Aggregation",
                };
                if (metric.dataPointType == DataPointType.SUM ||
                    metric.dataPointType == DataPointType.GAUGE) {
                    metricDataPoint.value = dataPoint.value;
                    metricDataPoint.count = 1;
                }
                else {
                    metricDataPoint.value = dataPoint.value.sum || 0;
                    metricDataPoint.count = dataPoint.value.count;
                    metricDataPoint.max = dataPoint.value.max;
                    metricDataPoint.min = dataPoint.value.min;
                }
                baseData.metrics.push(metricDataPoint);
                let envelope = {
                    name: envelopeName,
                    time: time,
                    sampleRate: 100,
                    instrumentationKey: instrumentationKey,
                    tags: tags,
                    version: 1,
                    data: {
                        baseType: "MetricData",
                        baseData: Object.assign({}, baseData),
                    },
                };
                envelopes.push(envelope);
            });
        });
    });
    return envelopes;
}
//# sourceMappingURL=metricUtils.js.map