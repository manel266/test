'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sdkTraceBase = require('@opentelemetry/sdk-trace-base');
var api = require('@opentelemetry/api');
var core = require('@opentelemetry/core');
var sdkMetrics = require('@opentelemetry/sdk-metrics');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var os$1 = require('os');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var url = require('url');
var coreClient = require('@azure/core-client');
var fs = require('fs');
var path = require('path');
var child_process = require('child_process');
var util = require('util');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);
var os__namespace = /*#__PURE__*/_interopNamespace(os$1);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os$1);
var url__default = /*#__PURE__*/_interopDefaultLegacy(url);
var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var child_process__namespace = /*#__PURE__*/_interopNamespace(child_process);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * AI MS Links.
 * @internal
 */
const MS_LINKS = "_MS.links";
/**
 * AI enqueued time attribute.
 * @internal
 */
const ENQUEUED_TIME = "enqueuedTime";
/**
 * AI time since enqueued attribute.
 * @internal
 */
const TIME_SINCE_ENQUEUED = "timeSinceEnqueued";
/**
 * AzureMonitorTraceExporter version.
 * @internal
 */
const packageVersion = "1.0.0-beta.14";
var DependencyTypes;
(function (DependencyTypes) {
    DependencyTypes["InProc"] = "InProc";
    DependencyTypes["QueueMessage"] = "Queue Message";
    DependencyTypes["Sql"] = "SQL";
    DependencyTypes["Http"] = "Http";
    DependencyTypes["Grpc"] = "GRPC";
})(DependencyTypes || (DependencyTypes = {}));
const AzureMonitorSampleRate = "_MS.sampleRate";
const ApplicationInsightsBaseType = "_MS.baseType";
const ApplicationInsightsMessageName = "Microsoft.ApplicationInsights.Message";
const ApplicationInsightsExceptionName = "Microsoft.ApplicationInsights.Exception";
const ApplicationInsightsPageViewName = "Microsoft.ApplicationInsights.PageView";
const ApplicationInsightsAvailabilityName = "Microsoft.ApplicationInsights.Availability";
const ApplicationInsightsEventName = "Microsoft.ApplicationInsights.Event";
const ApplicationInsightsMessageBaseType = "MessageData";
const ApplicationInsightsExceptionBaseType = "ExceptionData";
const ApplicationInsightsPageViewBaseType = "PageViewData";
const ApplicationInsightsAvailabilityBaseType = "AvailabilityData";
const ApplicationInsightsEventBaseType = "EventData";

/**
 * ApplicationInsightsSampler is responsible for the following:
 * Implements same trace id hashing algorithm so that traces are sampled the same across multiple nodes
 * Adds item count to span attribute if span is sampled (needed for ingestion service)
 * @param samplingRatio - 0 to 1 value.
 */
class ApplicationInsightsSampler {
    constructor(samplingRatio = 1) {
        this._samplingRatio = samplingRatio;
        if (this._samplingRatio > 1) {
            throw new Error("Wrong sampling rate, data will not be sampled out");
        }
        this._sampleRate = Math.round(this._samplingRatio * 100);
    }
    /**
     * Checks whether span needs to be created and tracked.
     *
     * @param context Parent Context which may contain a span.
     * @param traceId of the span to be created. It can be different from the
     *     traceId in the {@link SpanContext}. Typically in situations when the
     *     span to be created starts a new trace.
     * @param spanName of the span to be created.
     * @param spanKind of the span to be created.
     * @param attributes Initial set of SpanAttributes for the Span being constructed.
     * @param links Collection of links that will be associated with the Span to
     *     be created. Typically useful for batch operations.
     * @returns a {@link SamplingResult}.
     */
    shouldSample(
    // @ts-ignore
    context, traceId, 
    // @ts-ignore
    spanName, 
    // @ts-ignore
    spanKind, attributes, 
    // @ts-ignore
    links) {
        let isSampledIn = false;
        if (this._sampleRate == 100) {
            isSampledIn = true;
        }
        else if (this._sampleRate == 0) {
            isSampledIn = false;
        }
        else {
            isSampledIn = this._getSamplingHashCode(traceId) < this._sampleRate;
        }
        // Add sample rate as span attribute
        attributes = attributes || {};
        attributes[AzureMonitorSampleRate] = this._sampleRate;
        return isSampledIn
            ? { decision: sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED, attributes: attributes }
            : { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, attributes: attributes };
    }
    /**
     * Return Sampler description
     */
    toString() {
        return `ApplicationInsightsSampler{${this._samplingRatio}}`;
    }
    _getSamplingHashCode(input) {
        var csharpMin = -2147483648;
        var csharpMax = 2147483647;
        var hash = 5381;
        if (!input) {
            return 0;
        }
        while (input.length < 8) {
            input = input + input;
        }
        for (var i = 0; i < input.length; i++) {
            // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)
            hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i)) | 0;
        }
        hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
        return (hash / csharpMax) * 100;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure service API version.
 */
exports.ServiceApiVersion = void 0;
(function (ServiceApiVersion) {
    /**
     * V2 Version
     */
    ServiceApiVersion["V2"] = "2020-09-15_Preview";
})(exports.ServiceApiVersion || (exports.ServiceApiVersion = {}));
/**
 * Default Breeze endpoint.
 * @internal
 */
const DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
/**
 * Default Breeze API version.
 * @internal
 */
exports.ServiceApiVersion.V2;
/**
 * Default Live Metrics endpoint.
 * @internal
 */
const DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com";
/**
 * Connection string environment variable name.
 * @internal
 */
const ENV_CONNECTION_STRING = "APPLICATIONINSIGHTS_CONNECTION_STRING";
/**
 * Disable Statsbeat environment variable name.
 * @internal
 */
const ENV_DISABLE_STATSBEAT = "APPLICATION_INSIGHTS_NO_STATSBEAT";
/**
 * QuickPulse metric counter names.
 * @internal
 */
var QuickPulseCounter;
(function (QuickPulseCounter) {
    // Memory
    QuickPulseCounter["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
    // CPU
    QuickPulseCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    // Request
    QuickPulseCounter["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
    QuickPulseCounter["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
    QuickPulseCounter["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
    // Dependency
    QuickPulseCounter["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
    QuickPulseCounter["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
    QuickPulseCounter["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
    // Exception
    QuickPulseCounter["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
})(QuickPulseCounter || (QuickPulseCounter = {}));
/**
 * Performance metric counter names.
 * @internal
 */
var PerformanceCounter;
(function (PerformanceCounter) {
    // Memory
    PerformanceCounter["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    PerformanceCounter["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    // CPU
    PerformanceCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    PerformanceCounter["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    // Requests
    PerformanceCounter["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    PerformanceCounter["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(PerformanceCounter || (PerformanceCounter = {}));
/**
 * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*
 * @internal
 */
({
    [PerformanceCounter.PROCESSOR_TIME]: QuickPulseCounter.PROCESSOR_TIME,
    [PerformanceCounter.REQUEST_RATE]: QuickPulseCounter.REQUEST_RATE,
    [PerformanceCounter.REQUEST_DURATION]: QuickPulseCounter.REQUEST_DURATION,
    // Remap quick pulse only counters
    [QuickPulseCounter.COMMITTED_BYTES]: QuickPulseCounter.COMMITTED_BYTES,
    [QuickPulseCounter.REQUEST_FAILURE_RATE]: QuickPulseCounter.REQUEST_FAILURE_RATE,
    [QuickPulseCounter.DEPENDENCY_RATE]: QuickPulseCounter.DEPENDENCY_RATE,
    [QuickPulseCounter.DEPENDENCY_FAILURE_RATE]: QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
    [QuickPulseCounter.DEPENDENCY_DURATION]: QuickPulseCounter.DEPENDENCY_DURATION,
    [QuickPulseCounter.EXCEPTION_RATE]: QuickPulseCounter.EXCEPTION_RATE,
});

// Copyright (c) Microsoft Corporation.
/**
 * ConnectionString parser.
 * @internal
 */
class ConnectionStringParser {
    static parse(connectionString) {
        if (!connectionString) {
            return {};
        }
        const kvPairs = connectionString.split(ConnectionStringParser.FIELDS_SEPARATOR);
        let isValid = true;
        const result = kvPairs.reduce((fields, kv) => {
            const kvParts = kv.split(ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
                // only save fields with valid formats
                const key = kvParts[0].toLowerCase();
                const value = kvParts[1];
                return Object.assign(Object.assign({}, fields), { [key]: value });
            }
            api.diag.error(`Connection string key-value pair is invalid: ${kv}`, `Entire connection string will be discarded`, connectionString);
            isValid = false;
            return fields;
        }, {});
        if (isValid && Object.keys(result).length > 0) {
            // this is a valid connection string, so parse the results
            if (result.endpointsuffix) {
                // use endpoint suffix where overrides are not provided
                const locationPrefix = result.location ? `${result.location}.` : "";
                result.ingestionendpoint =
                    result.ingestionendpoint || `https://${locationPrefix}dc.${result.endpointsuffix}`;
                result.liveendpoint =
                    result.liveendpoint || `https://${locationPrefix}live.${result.endpointsuffix}`;
            }
            result.ingestionendpoint = result.ingestionendpoint
                ? ConnectionStringParser.sanitizeUrl(result.ingestionendpoint)
                : DEFAULT_BREEZE_ENDPOINT;
            result.liveendpoint = result.liveendpoint
                ? ConnectionStringParser.sanitizeUrl(result.liveendpoint)
                : DEFAULT_LIVEMETRICS_ENDPOINT;
            if (result.authorization && result.authorization.toLowerCase() !== "ikey") {
                api.diag.warn(`Connection String contains an unsupported 'Authorization' value: ${result.authorization}. Defaulting to 'Authorization=ikey'. Instrumentation Key ${result.instrumentationkey}`);
            }
        }
        else {
            api.diag.error("An invalid connection string was passed in. There may be telemetry loss", connectionString);
        }
        return result;
    }
    static sanitizeUrl(url) {
        let newUrl = url.trim();
        if (newUrl.indexOf("https://") < 0) {
            // Try to update http to https
            newUrl = newUrl.replace("http://", "https://");
        }
        // Remove final slash if present
        if (newUrl[newUrl.length - 1] == "/") {
            newUrl = newUrl.slice(0, -1);
        }
        return newUrl;
    }
}
ConnectionStringParser.FIELDS_SEPARATOR = ";";
ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR = "=";

// Copyright (c) Microsoft Corporation.
class FileAccessControl {
    // Check if file access control could be enabled
    static checkFileProtection() {
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION &&
            !FileAccessControl.OS_FILE_PROTECTION_CHECKED) {
            FileAccessControl.OS_FILE_PROTECTION_CHECKED = true;
            // Node's chmod levels do not appropriately restrict file access on Windows
            // Use the built-in command line tool ICACLS on Windows to properly restrict
            // access to the temporary directory used for disk retry mode.
            if (FileAccessControl.USE_ICACLS) {
                // This should be async - but it's currently safer to have this synchronous
                // This guarantees we can immediately fail setDiskRetryMode if we need to
                try {
                    FileAccessControl.OS_PROVIDES_FILE_PROTECTION = fs__namespace.existsSync(FileAccessControl.ICACLS_PATH);
                }
                catch (e) {
                    // Ignore error
                }
                if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
                    api.diag.warn("Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
                }
            }
            else {
                // chmod works everywhere else
                FileAccessControl.OS_PROVIDES_FILE_PROTECTION = true;
            }
        }
    }
    static async applyACLRules(directory) {
        if (FileAccessControl.USE_ICACLS) {
            if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {
                // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately
                // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk
                // This is better than the alternative of potentially infinitely spawned processes
                FileAccessControl.ACLED_DIRECTORIES[directory] = false;
                try {
                    // Restrict this directory to only current user and administrator access
                    let identity = await this._getACLIdentity();
                    await this._runICACLS(this._getACLArguments(directory, identity));
                    FileAccessControl.ACLED_DIRECTORIES[directory] = true;
                }
                catch (ex) {
                    FileAccessControl.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is "not yet tried")
                    throw ex;
                }
            }
            else {
                if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {
                    throw new Error("Setting ACL restrictions did not succeed (cached result)");
                }
            }
        }
    }
    static applyACLRulesSync(directory) {
        if (FileAccessControl.USE_ICACLS) {
            // For performance, only run ACL rules if we haven't already during this session
            if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {
                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
                FileAccessControl.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures
                return;
            }
            else if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {
                // falsy but not undefined
                throw new Error("Setting ACL restrictions did not succeed (cached result)");
            }
        }
    }
    static _runICACLS(args) {
        return new Promise((resolve, reject) => {
            var aclProc = child_process__namespace.spawn(FileAccessControl.ICACLS_PATH, args, {
                windowsHide: true,
            });
            aclProc.on("error", (e) => reject(e));
            aclProc.on("close", (code) => {
                if (code === 0) {
                    resolve();
                }
                else {
                    reject(new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${code})`));
                }
            });
        });
    }
    static _runICACLSSync(args) {
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process__namespace.spawnSync) {
            var aclProc = child_process__namespace.spawnSync(FileAccessControl.ICACLS_PATH, args, {
                windowsHide: true,
            });
            if (aclProc.error) {
                throw aclProc.error;
            }
            else if (aclProc.status !== 0) {
                throw new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${aclProc.status})`);
            }
        }
        else {
            throw new Error("Could not synchronously call ICACLS under current version of Node.js");
        }
    }
    static _getACLIdentity() {
        return new Promise((resolve, reject) => {
            if (FileAccessControl.ACL_IDENTITY) {
                resolve(FileAccessControl.ACL_IDENTITY);
            }
            var psProc = child_process__namespace.spawn(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ["ignore", "pipe", "pipe"], // Needed to prevent hanging on Win 7
            });
            let data = "";
            psProc.stdout.on("data", (d) => (data += d));
            psProc.on("error", (e) => reject(e));
            psProc.on("close", (code) => {
                FileAccessControl.ACL_IDENTITY = data && data.trim();
                if (code === 0) {
                    resolve(FileAccessControl.ACL_IDENTITY);
                }
                else {
                    reject(new Error(`Getting ACL identity did not succeed (PS returned code ${code})`));
                }
            });
        });
    }
    static _getACLIdentitySync() {
        if (FileAccessControl.ACL_IDENTITY) {
            return FileAccessControl.ACL_IDENTITY;
        }
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process__namespace.spawnSync) {
            var psProc = child_process__namespace.spawnSync(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ["ignore", "pipe", "pipe"], // Needed to prevent hanging on Win 7
            });
            if (psProc.error) {
                throw psProc.error;
            }
            else if (psProc.status !== 0) {
                throw new Error(`Getting ACL identity did not succeed (PS returned code ${psProc.status})`);
            }
            FileAccessControl.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
            return FileAccessControl.ACL_IDENTITY;
        }
        else {
            throw new Error("Could not synchronously get ACL identity under current version of Node.js");
        }
    }
    static _getACLArguments(directory, identity) {
        return [
            directory,
            "/grant",
            "*S-1-5-32-544:(OI)(CI)F",
            "/grant",
            `${identity}:(OI)(CI)F`,
            "/inheritance:r",
        ]; // Remove all inherited permissions
    }
}
FileAccessControl.ICACLS_PATH = `${process.env.systemdrive}/windows/system32/icacls.exe`;
FileAccessControl.POWERSHELL_PATH = `${process.env.systemdrive}/windows/system32/windowspowershell/v1.0/powershell.exe`;
FileAccessControl.ACLED_DIRECTORIES = {};
FileAccessControl.ACL_IDENTITY = null;
FileAccessControl.OS_FILE_PROTECTION_CHECKED = false;
FileAccessControl.OS_PROVIDES_FILE_PROTECTION = false;
FileAccessControl.USE_ICACLS = os__namespace.type() === "Windows_NT";

// Copyright (c) Microsoft Corporation.
const readdirAsync$1 = util.promisify(fs__namespace.readdir);
const statAsync$1 = util.promisify(fs__namespace.stat);
const lstatAsync = util.promisify(fs__namespace.lstat);
const mkdirAsync = util.promisify(fs__namespace.mkdir);
/**
 * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.
 * @internal
 */
const getShallowDirectorySize = async (directory) => {
    // Get the directory listing
    const files = await readdirAsync$1(directory);
    let totalSize = 0;
    // Query all file sizes
    for (const file of files) {
        const fileStats = await statAsync$1(path__namespace.join(directory, file));
        if (fileStats.isFile()) {
            totalSize += fileStats.size;
        }
    }
    return totalSize;
};
/**
 * Validate directory exists.
 * @internal
 */
const confirmDirExists = async (directory) => {
    try {
        const stats = await lstatAsync(directory);
        if (!stats.isDirectory()) {
            throw new Error("Path existed but was not a directory");
        }
    }
    catch (err) {
        if (err && err.code === "ENOENT") {
            try {
                const options = { recursive: true };
                await mkdirAsync(directory, options);
            }
            catch (mkdirErr) {
                if (mkdirErr && mkdirErr.code !== "EEXIST") {
                    // Handle race condition by ignoring EEXIST
                    throw mkdirErr;
                }
            }
        }
    }
};

// Copyright (c) Microsoft Corporation.
const statAsync = util.promisify(fs__namespace.stat);
const readdirAsync = util.promisify(fs__namespace.readdir);
const readFileAsync = util.promisify(fs__namespace.readFile);
const unlinkAsync = util.promisify(fs__namespace.unlink);
const writeFileAsync = util.promisify(fs__namespace.writeFile);
/**
 * File system persist class.
 * @internal
 */
class FileSystemPersist {
    constructor(instrumentationKey, _options) {
        var _a, _b;
        this._options = _options;
        this.fileRetemptionPeriod = 2 * 24 * 60 * 60 * 1000; // 2 days
        this.cleanupTimeOut = 60 * 60 * 1000; // 1 hour
        this.maxBytesOnDisk = 50000000; // ~50MB
        this._tempDirectory = "";
        this._fileCleanupTimer = null;
        this._instrumentationKey = instrumentationKey;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.disableOfflineStorage) {
            this._enabled = false;
            return;
        }
        this._enabled = true;
        FileAccessControl.checkFileProtection();
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
            this._enabled = false;
            api.diag.error("Sufficient file protection capabilities were not detected. Files will not be persisted");
        }
        if (!this._instrumentationKey) {
            this._enabled = false;
            api.diag.error(`No instrumentation key was provided to FileSystemPersister. Files will not be persisted`);
        }
        if (this._enabled) {
            this._tempDirectory = path__namespace.join(((_b = this._options) === null || _b === void 0 ? void 0 : _b.storageDirectory) || os__namespace.tmpdir(), "Microsoft", "AzureMonitor", FileSystemPersist.TEMPDIR_PREFIX + this._instrumentationKey);
            // Starts file cleanup task
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setTimeout(() => {
                    this._fileCleanupTask();
                }, this.cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    push(value) {
        if (this._enabled) {
            api.diag.debug("Pushing value to persistent storage", value.toString());
            return this._storeToDisk(JSON.stringify(value));
        }
        return new Promise((resolve) => {
            resolve(false);
        });
    }
    async shift() {
        if (this._enabled) {
            api.diag.debug("Searching for filesystem persisted files");
            try {
                const buffer = await this._getFirstFileOnDisk();
                if (buffer) {
                    return JSON.parse(buffer.toString("utf8"));
                }
            }
            catch (e) {
                api.diag.debug("Failed to read persisted file", e);
            }
            return null;
        }
        return new Promise((resolve) => {
            resolve(null);
        });
    }
    /**
     * Check for temp telemetry files
     * reads the first file if exist, deletes it and tries to send its load
     */
    async _getFirstFileOnDisk() {
        try {
            const stats = await statAsync(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await readdirAsync(this._tempDirectory);
                const files = origFiles.filter((f) => path__namespace.basename(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return null;
                }
                else {
                    const firstFile = files[0];
                    const filePath = path__namespace.join(this._tempDirectory, firstFile);
                    const payload = await readFileAsync(filePath);
                    // delete the file first to prevent double sending
                    await unlinkAsync(filePath);
                    return payload;
                }
            }
            return null;
        }
        catch (e) {
            if (e.code === "ENOENT") {
                // File does not exist -- return null instead of throwing
                return null;
            }
            else {
                throw e;
            }
        }
    }
    async _storeToDisk(payload) {
        try {
            await confirmDirExists(this._tempDirectory);
        }
        catch (error) {
            api.diag.warn(`Error while checking/creating directory: `, error && error.message);
            return false;
        }
        try {
            const size = await getShallowDirectorySize(this._tempDirectory);
            if (size > this.maxBytesOnDisk) {
                api.diag.warn(`Not saving data due to max size limit being met. Directory size in bytes is: ${size}`);
                return false;
            }
        }
        catch (error) {
            api.diag.warn(`Error while checking size of persistence directory: `, error && error.message);
            return false;
        }
        const fileName = `${new Date().getTime()}${FileSystemPersist.FILENAME_SUFFIX}`;
        const fileFullPath = path__namespace.join(this._tempDirectory, fileName);
        // Mode 600 is w/r for creator and no read access for others
        api.diag.info(`saving data to disk at: ${fileFullPath}`);
        try {
            await writeFileAsync(fileFullPath, payload, { mode: 0o600 });
        }
        catch (writeError) {
            api.diag.warn(`Error writing file to persistent file storage`, writeError);
            return false;
        }
        return true;
    }
    async _fileCleanupTask() {
        try {
            const stats = await statAsync(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await readdirAsync(this._tempDirectory);
                const files = origFiles.filter((f) => path__namespace.basename(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return false;
                }
                else {
                    files.forEach(async (file) => {
                        // Check expiration
                        const fileCreationDate = new Date(parseInt(file.split(FileSystemPersist.FILENAME_SUFFIX)[0]));
                        const expired = new Date(+new Date() - this.fileRetemptionPeriod) > fileCreationDate;
                        if (expired) {
                            const filePath = path__namespace.join(this._tempDirectory, file);
                            await unlinkAsync(filePath);
                        }
                    });
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            api.diag.info(`Failed cleanup of persistent file storage expired files`, error);
            return false;
        }
    }
}
FileSystemPersist.TEMPDIR_PREFIX = "ot-azure-exporter-";
FileSystemPersist.FILENAME_SUFFIX = ".ai.json";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DataPointType} that the service accepts. */
var KnownDataPointType;
(function (KnownDataPointType) {
    /** Measurement */
    KnownDataPointType["Measurement"] = "Measurement";
    /** Aggregation */
    KnownDataPointType["Aggregation"] = "Aggregation";
})(KnownDataPointType || (KnownDataPointType = {}));
/** Known values of {@link SeverityLevel} that the service accepts. */
var KnownSeverityLevel;
(function (KnownSeverityLevel) {
    /** Verbose */
    KnownSeverityLevel["Verbose"] = "Verbose";
    /** Information */
    KnownSeverityLevel["Information"] = "Information";
    /** Warning */
    KnownSeverityLevel["Warning"] = "Warning";
    /** Error */
    KnownSeverityLevel["Error"] = "Error";
    /** Critical */
    KnownSeverityLevel["Critical"] = "Critical";
})(KnownSeverityLevel || (KnownSeverityLevel = {}));
/** Known values of {@link ContextTagKeys} that the service accepts. */
var KnownContextTagKeys;
(function (KnownContextTagKeys) {
    /** AiApplicationVer */
    KnownContextTagKeys["AiApplicationVer"] = "ai.application.ver";
    /** AiDeviceId */
    KnownContextTagKeys["AiDeviceId"] = "ai.device.id";
    /** AiDeviceLocale */
    KnownContextTagKeys["AiDeviceLocale"] = "ai.device.locale";
    /** AiDeviceModel */
    KnownContextTagKeys["AiDeviceModel"] = "ai.device.model";
    /** AiDeviceOemName */
    KnownContextTagKeys["AiDeviceOemName"] = "ai.device.oemName";
    /** AiDeviceOsVersion */
    KnownContextTagKeys["AiDeviceOsVersion"] = "ai.device.osVersion";
    /** AiDeviceType */
    KnownContextTagKeys["AiDeviceType"] = "ai.device.type";
    /** AiLocationIp */
    KnownContextTagKeys["AiLocationIp"] = "ai.location.ip";
    /** AiLocationCountry */
    KnownContextTagKeys["AiLocationCountry"] = "ai.location.country";
    /** AiLocationProvince */
    KnownContextTagKeys["AiLocationProvince"] = "ai.location.province";
    /** AiLocationCity */
    KnownContextTagKeys["AiLocationCity"] = "ai.location.city";
    /** AiOperationId */
    KnownContextTagKeys["AiOperationId"] = "ai.operation.id";
    /** AiOperationName */
    KnownContextTagKeys["AiOperationName"] = "ai.operation.name";
    /** AiOperationParentId */
    KnownContextTagKeys["AiOperationParentId"] = "ai.operation.parentId";
    /** AiOperationSyntheticSource */
    KnownContextTagKeys["AiOperationSyntheticSource"] = "ai.operation.syntheticSource";
    /** AiOperationCorrelationVector */
    KnownContextTagKeys["AiOperationCorrelationVector"] = "ai.operation.correlationVector";
    /** AiSessionId */
    KnownContextTagKeys["AiSessionId"] = "ai.session.id";
    /** AiSessionIsFirst */
    KnownContextTagKeys["AiSessionIsFirst"] = "ai.session.isFirst";
    /** AiUserAccountId */
    KnownContextTagKeys["AiUserAccountId"] = "ai.user.accountId";
    /** AiUserId */
    KnownContextTagKeys["AiUserId"] = "ai.user.id";
    /** AiUserAuthUserId */
    KnownContextTagKeys["AiUserAuthUserId"] = "ai.user.authUserId";
    /** AiCloudRole */
    KnownContextTagKeys["AiCloudRole"] = "ai.cloud.role";
    /** AiCloudRoleVer */
    KnownContextTagKeys["AiCloudRoleVer"] = "ai.cloud.roleVer";
    /** AiCloudRoleInstance */
    KnownContextTagKeys["AiCloudRoleInstance"] = "ai.cloud.roleInstance";
    /** AiCloudLocation */
    KnownContextTagKeys["AiCloudLocation"] = "ai.cloud.location";
    /** AiInternalSdkVersion */
    KnownContextTagKeys["AiInternalSdkVersion"] = "ai.internal.sdkVersion";
    /** AiInternalAgentVersion */
    KnownContextTagKeys["AiInternalAgentVersion"] = "ai.internal.agentVersion";
    /** AiInternalNodeName */
    KnownContextTagKeys["AiInternalNodeName"] = "ai.internal.nodeName";
})(KnownContextTagKeys || (KnownContextTagKeys = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: {
        serializedName: "body",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "TelemetryItem"
                }
            }
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const host = {
    parameterPath: "host",
    mapper: {
        serializedName: "Host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const TelemetryItem = {
    type: {
        name: "Composite",
        className: "TelemetryItem",
        modelProperties: {
            version: {
                defaultValue: 1,
                serializedName: "ver",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            time: {
                serializedName: "time",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            sampleRate: {
                defaultValue: 100,
                serializedName: "sampleRate",
                type: {
                    name: "Number"
                }
            },
            sequence: {
                constraints: {
                    MaxLength: 64
                },
                serializedName: "seq",
                type: {
                    name: "String"
                }
            },
            instrumentationKey: {
                serializedName: "iKey",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Composite",
                    className: "MonitorBase"
                }
            }
        }
    }
};
const MonitorBase = {
    type: {
        name: "Composite",
        className: "MonitorBase",
        modelProperties: {
            baseType: {
                serializedName: "baseType",
                type: {
                    name: "String"
                }
            },
            baseData: {
                serializedName: "baseData",
                type: {
                    name: "Composite",
                    className: "MonitorDomain"
                }
            }
        }
    }
};
const MonitorDomain = {
    type: {
        name: "Composite",
        className: "MonitorDomain",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            version: {
                defaultValue: 2,
                serializedName: "ver",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TrackResponse = {
    type: {
        name: "Composite",
        className: "TrackResponse",
        modelProperties: {
            itemsReceived: {
                serializedName: "itemsReceived",
                type: {
                    name: "Number"
                }
            },
            itemsAccepted: {
                serializedName: "itemsAccepted",
                type: {
                    name: "Number"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TelemetryErrorDetails"
                        }
                    }
                }
            }
        }
    }
};
const TelemetryErrorDetails = {
    type: {
        name: "Composite",
        className: "TelemetryErrorDetails",
        modelProperties: {
            index: {
                serializedName: "index",
                type: {
                    name: "Number"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricDataPoint = {
    type: {
        name: "Composite",
        className: "MetricDataPoint",
        modelProperties: {
            namespace: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "ns",
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataPointType: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            },
            count: {
                serializedName: "count",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            min: {
                serializedName: "min",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            max: {
                serializedName: "max",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            stdDev: {
                serializedName: "stdDev",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TelemetryExceptionDetails = {
    type: {
        name: "Composite",
        className: "TelemetryExceptionDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            outerId: {
                serializedName: "outerId",
                type: {
                    name: "Number"
                }
            },
            typeName: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            message: {
                constraints: {
                    MaxLength: 32768
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            hasFullStack: {
                defaultValue: true,
                serializedName: "hasFullStack",
                type: {
                    name: "Boolean"
                }
            },
            stack: {
                constraints: {
                    MaxLength: 32768
                },
                serializedName: "stack",
                type: {
                    name: "String"
                }
            },
            parsedStack: {
                serializedName: "parsedStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackFrame"
                        }
                    }
                }
            }
        }
    }
};
const StackFrame = {
    type: {
        name: "Composite",
        className: "StackFrame",
        modelProperties: {
            level: {
                serializedName: "level",
                required: true,
                type: {
                    name: "Number"
                }
            },
            method: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "method",
                required: true,
                type: {
                    name: "String"
                }
            },
            assembly: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "assembly",
                type: {
                    name: "String"
                }
            },
            fileName: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "fileName",
                type: {
                    name: "String"
                }
            },
            line: {
                serializedName: "line",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AvailabilityData = {
    type: {
        name: "Composite",
        className: "AvailabilityData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            }, success: {
                serializedName: "success",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, runLocation: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "runLocation",
                type: {
                    name: "String"
                }
            }, message: {
                constraints: {
                    MaxLength: 8192
                },
                serializedName: "message",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const TelemetryEventData = {
    type: {
        name: "Composite",
        className: "TelemetryEventData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { name: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const TelemetryExceptionData = {
    type: {
        name: "Composite",
        className: "TelemetryExceptionData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { exceptions: {
                serializedName: "exceptions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TelemetryExceptionDetails"
                        }
                    }
                }
            }, severityLevel: {
                serializedName: "severityLevel",
                nullable: true,
                type: {
                    name: "String"
                }
            }, problemId: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "problemId",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const MessageData = {
    type: {
        name: "Composite",
        className: "MessageData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { message: {
                constraints: {
                    MaxLength: 32768
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }, severityLevel: {
                serializedName: "severityLevel",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const MetricsData = {
    type: {
        name: "Composite",
        className: "MetricsData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { metrics: {
                serializedName: "metrics",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDataPoint"
                        }
                    }
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            } })
    }
};
const PageViewData = {
    type: {
        name: "Composite",
        className: "PageViewData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, url: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }, referredUri: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "referredUri",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const PageViewPerfData = {
    type: {
        name: "Composite",
        className: "PageViewPerfData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, url: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }, perfTotal: {
                serializedName: "perfTotal",
                type: {
                    name: "String"
                }
            }, networkConnect: {
                serializedName: "networkConnect",
                type: {
                    name: "String"
                }
            }, sentRequest: {
                serializedName: "sentRequest",
                type: {
                    name: "String"
                }
            }, receivedResponse: {
                serializedName: "receivedResponse",
                type: {
                    name: "String"
                }
            }, domProcessing: {
                serializedName: "domProcessing",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const RemoteDependencyData = {
    type: {
        name: "Composite",
        className: "RemoteDependencyData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, resultCode: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "resultCode",
                type: {
                    name: "String"
                }
            }, data: {
                constraints: {
                    MaxLength: 8192
                },
                serializedName: "data",
                type: {
                    name: "String"
                }
            }, type: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, target: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "target",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            }, success: {
                defaultValue: true,
                serializedName: "success",
                type: {
                    name: "Boolean"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const RequestData = {
    type: {
        name: "Composite",
        className: "RequestData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            }, success: {
                defaultValue: true,
                serializedName: "success",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, responseCode: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "responseCode",
                required: true,
                type: {
                    name: "String"
                }
            }, source: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "source",
                type: {
                    name: "String"
                }
            }, url: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TelemetryItem: TelemetryItem,
    MonitorBase: MonitorBase,
    MonitorDomain: MonitorDomain,
    TrackResponse: TrackResponse,
    TelemetryErrorDetails: TelemetryErrorDetails,
    MetricDataPoint: MetricDataPoint,
    TelemetryExceptionDetails: TelemetryExceptionDetails,
    StackFrame: StackFrame,
    AvailabilityData: AvailabilityData,
    TelemetryEventData: TelemetryEventData,
    TelemetryExceptionData: TelemetryExceptionData,
    MessageData: MessageData,
    MetricsData: MetricsData,
    PageViewData: PageViewData,
    PageViewPerfData: PageViewPerfData,
    RemoteDependencyData: RemoteDependencyData,
    RequestData: RequestData
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ApplicationInsightsClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ApplicationInsightsClient class.
     * @param options The parameter options
     */
    constructor(options) {
        var _a, _b;
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-monitor-opentelemetry-exporter/1.0.0-beta.14`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{Host}/v2.1" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Assigning values to Constant parameters
        this.host = options.host || "https://dc.services.visualstudio.com";
    }
    /**
     * This operation sends a sequence of telemetry events that will be monitored by Azure Monitor.
     * @param body The list of telemetry events to track.
     * @param options The options parameters.
     */
    track(body, options) {
        return this.sendOperationRequest({ body, options }, trackOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const trackOperationSpec = {
    path: "/track",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TrackResponse
        },
        206: {
            bodyMapper: TrackResponse
        },
        400: {
            bodyMapper: TrackResponse,
            isError: true
        },
        402: {
            bodyMapper: TrackResponse,
            isError: true
        },
        429: {
            bodyMapper: TrackResponse,
            isError: true
        },
        500: {
            bodyMapper: TrackResponse,
            isError: true
        },
        503: {
            bodyMapper: TrackResponse,
            isError: true
        }
    },
    requestBody: body,
    urlParameters: [host],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
const applicationInsightsResource = "https://monitor.azure.com//.default";
/**
 * Exporter HTTP sender class
 * @internal
 */
class HttpSender {
    constructor(endpointUrl, options) {
        // Build endpoint using provided configuration or default values
        this._appInsightsClientOptions = Object.assign({ host: endpointUrl }, options);
        this._appInsightsClient = new ApplicationInsightsClient(this._appInsightsClientOptions);
        // Handle redirects in HTTP Sender
        this._appInsightsClient.pipeline.removePolicy({ name: coreRestPipeline.redirectPolicyName });
        if (options === null || options === void 0 ? void 0 : options.aadTokenCredential) {
            let scopes = [applicationInsightsResource];
            this._appInsightsClient.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential: options === null || options === void 0 ? void 0 : options.aadTokenCredential,
                scopes: scopes,
            }));
        }
    }
    /**
     * Send Azure envelopes
     * @internal
     */
    async send(envelopes) {
        var _a;
        let options = {};
        try {
            let response;
            function onResponse(rawResponse, flatResponse) {
                response = rawResponse;
                if (options.onResponse) {
                    options.onResponse(rawResponse, flatResponse);
                }
            }
            await this._appInsightsClient.track(envelopes, Object.assign(Object.assign({}, options), { onResponse }));
            return { statusCode: response === null || response === void 0 ? void 0 : response.status, result: (_a = response === null || response === void 0 ? void 0 : response.bodyAsText) !== null && _a !== void 0 ? _a : "" };
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Shutdown sender
     * @internal
     */
    async shutdown() {
        api.diag.info("HttpSender shutting down");
    }
    handlePermanentRedirect(location) {
        if (location) {
            const locUrl = new url__default["default"].URL(location);
            if (locUrl && locUrl.host) {
                this._appInsightsClient.host = "https://" + locUrl.host;
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
let instance$1 = null;
/**
 * Azure Telemetry context.
 * @internal
 */
class Context {
    constructor() {
        this.tags = {};
        this._loadDeviceContext();
        this._loadInternalContext();
    }
    _loadDeviceContext() {
        this.tags[KnownContextTagKeys.AiDeviceOsVersion] = os__namespace && `${os__namespace.type()} ${os__namespace.release()}`;
    }
    _loadInternalContext() {
        const { node } = process.versions;
        [Context.nodeVersion] = node.split(".");
        Context.opentelemetryVersion = core.SDK_INFO[semanticConventions.SemanticResourceAttributes.TELEMETRY_SDK_VERSION];
        Context.sdkVersion = packageVersion;
        let prefix = process.env["AZURE_MONITOR_AGENT_PREFIX"]
            ? process.env["AZURE_MONITOR_AGENT_PREFIX"]
            : "";
        let version = process.env["AZURE_MONITOR_DISTRO_VERSION"]
            ? `dst${process.env["AZURE_MONITOR_DISTRO_VERSION"]}`
            : `ext${Context.sdkVersion}`;
        let internalSdkVersion = `${prefix}node${Context.nodeVersion}:otel${Context.opentelemetryVersion}:${version}`;
        this.tags[KnownContextTagKeys.AiInternalSdkVersion] = internalSdkVersion;
    }
}
Context.sdkVersion = null;
Context.opentelemetryVersion = null;
Context.nodeVersion = "";
/**
 * Singleton Context instance
 * @internal
 */
function getInstance$1() {
    if (!instance$1) {
        instance$1 = new Context();
    }
    return instance$1;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Breeze retriable status codes.
 * @internal
 */
function isRetriable(statusCode) {
    return (statusCode === 206 || // Partial Accept
        statusCode === 401 || // Unauthorized
        statusCode === 403 || // Forbidden
        statusCode === 408 || // Timeout
        statusCode === 429 || // Too many requests
        statusCode === 439 || // Daily quota exceeded (legacy)
        statusCode === 500 || // Server Error
        statusCode === 502 || // Bad Gateway
        statusCode === 503 || // Server Unavailable
        statusCode === 504 // Gateway Timeout
    );
}
/**
 * Convert milliseconds to Breeze expected time.
 * @internal
 */
function msToTimeSpan(ms) {
    let totalms = ms;
    if (Number.isNaN(totalms) || totalms < 0 || !Number.isFinite(ms)) {
        totalms = 0;
    }
    let sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, "");
    let min = `${Math.floor(totalms / (1000 * 60)) % 60}`;
    let hour = `${Math.floor(totalms / (1000 * 60 * 60)) % 24}`;
    const days = Math.floor(totalms / (1000 * 60 * 60 * 24));
    sec = sec.indexOf(".") < 2 ? `0${sec}` : sec;
    min = min.length < 2 ? `0${min}` : min;
    hour = hour.length < 2 ? `0${hour}` : hour;
    const daysText = days > 0 ? `${days}.` : "";
    return `${daysText + hour}:${min}:${sec}`;
}

class NetworkStatsbeat {
    constructor(endpoint, host) {
        this.endpoint = endpoint;
        this.host = host;
        this.totalRequestCount = 0;
        this.totalSuccesfulRequestCount = 0;
        this.totalFailedRequestCount = [];
        this.retryCount = [];
        this.exceptionCount = [];
        this.throttleCount = [];
        this.intervalRequestExecutionTime = 0;
        this.lastIntervalRequestExecutionTime = 0;
        this.lastTime = +new Date();
        this.lastRequestCount = 0;
        this.averageRequestExecutionTime = 0;
    }
}
const STATSBEAT_LANGUAGE = "node";
const MAX_STATSBEAT_FAILURES = 3;
const StatsbeatResourceProvider = {
    appsvc: "appsvc",
    functions: "functions",
    vm: "vm",
    unknown: "unknown",
};
var StatsbeatCounter;
(function (StatsbeatCounter) {
    StatsbeatCounter["SUCCESS_COUNT"] = "Request Success Count";
    StatsbeatCounter["FAILURE_COUNT"] = "Request Failure Count";
    StatsbeatCounter["RETRY_COUNT"] = "Retry Count";
    StatsbeatCounter["THROTTLE_COUNT"] = "Throttle Count";
    StatsbeatCounter["EXCEPTION_COUNT"] = "Exception Count";
    StatsbeatCounter["AVERAGE_DURATION"] = "Request Duration";
    StatsbeatCounter["ATTACH"] = "Attach";
    StatsbeatCounter["FEATURE"] = "Feature";
})(StatsbeatCounter || (StatsbeatCounter = {}));
const AIMS_URI = "http://169.254.169.254/metadata/instance/compute";
const AIMS_API_VERSION = "api-version=2017-12-01";
const AIMS_FORMAT = "format=json";
const NON_EU_CONNECTION_STRING = "InstrumentationKey=c4a29126-a7cb-47e5-b348-11414998b11e;IngestionEndpoint=https://westus-0.in.applicationinsights.azure.com";
const EU_CONNECTION_STRING = "InstrumentationKey=7dc56bab-3c0c-4e9f-9ebb-d1acadee8d0f;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com";
const EU_ENDPOINTS = [
    "westeurope",
    "northeurope",
    "francecentral",
    "francesouth",
    "germanywestcentral",
    "norwayeast",
    "norwaywest",
    "swedencentral",
    "switzerlandnorth",
    "switzerlandwest",
    "uksouth",
    "ukwest",
];
var StatsbeatFeatureType;
(function (StatsbeatFeatureType) {
    StatsbeatFeatureType["FEATURE"] = "Feature";
    StatsbeatFeatureType["INSTRUMENTATION"] = "Instrumentation";
})(StatsbeatFeatureType || (StatsbeatFeatureType = {}));

// Copyright (c) Microsoft Corporation.
const os = require("os");
class StatsbeatMetrics {
    constructor() {
        this._resourceProvider = StatsbeatResourceProvider.unknown;
        this._vmInfo = {};
        this._os = os.type();
        this._resourceIdentifier = "";
    }
    async _getResourceProvider() {
        // Check resource provider
        this._resourceProvider = StatsbeatResourceProvider.unknown;
        if (process.env.WEBSITE_SITE_NAME) {
            // Web apps
            this._resourceProvider = StatsbeatResourceProvider.appsvc;
        }
        else if (process.env.FUNCTIONS_WORKER_RUNTIME) {
            // Function apps
            this._resourceProvider = StatsbeatResourceProvider.functions;
        }
        else if (await this.getAzureComputeMetadata()) {
            this._resourceProvider = StatsbeatResourceProvider.vm;
            this._resourceIdentifier = this._vmInfo.id + "/" + this._vmInfo.subscriptionId;
            // Overrride OS as VM info have higher precedence
            if (this._vmInfo.osType) {
                this._os = this._vmInfo.osType;
            }
        }
        else {
            this._resourceProvider = StatsbeatResourceProvider.unknown;
        }
    }
    async getAzureComputeMetadata() {
        const httpClient = coreRestPipeline.createDefaultHttpClient();
        const method = "GET";
        const options = {
            url: `${AIMS_URI}?${AIMS_API_VERSION}&${AIMS_FORMAT}`,
            timeout: 5000,
            method: method,
            allowInsecureConnection: true,
        };
        const request = coreRestPipeline.createPipelineRequest(options);
        await httpClient
            .sendRequest(request)
            .then((res) => {
            if (res.status === 200) {
                // Success; VM
                this._vmInfo.isVM = true;
                let virtualMachineData = "";
                res.on("data", (data) => {
                    virtualMachineData += data;
                });
                res.on("end", () => {
                    try {
                        let data = JSON.parse(virtualMachineData);
                        this._vmInfo.id = data["vmId"] || "";
                        this._vmInfo.subscriptionId = data["subscriptionId"] || "";
                        this._vmInfo.osType = data["osType"] || "";
                    }
                    catch (error) {
                        api.diag.debug("Failed to parse JSON: ", error);
                    }
                });
                return true;
            }
            else {
                return false;
            }
        })
            .catch(() => {
            return false;
        });
        return false;
    }
    _getConnectionString(endpointUrl) {
        let currentEndpoint = endpointUrl;
        for (let i = 0; i < EU_ENDPOINTS.length; i++) {
            if (currentEndpoint.includes(EU_ENDPOINTS[i])) {
                return EU_CONNECTION_STRING;
            }
        }
        return NON_EU_CONNECTION_STRING;
    }
}

// Copyright (c) Microsoft Corporation.
class NetworkStatsbeatMetrics extends StatsbeatMetrics {
    constructor(options) {
        super();
        this._isInitialized = false;
        this._statsCollectionShortInterval = 900000; // 15 minutes
        this._networkStatsbeatCollection = [];
        this._attach = "sdk";
        this._connectionString = super._getConnectionString(options.endpointUrl);
        this._networkStatsbeatMeterProvider = new sdkMetrics.MeterProvider();
        const exporterConfig = {
            connectionString: this._connectionString,
        };
        this._networkAzureExporter = new AzureMonitorStatsbeatExporter(exporterConfig);
        // Exports Network Statsbeat every 15 minutes
        const networkMetricReaderOptions = {
            exporter: this._networkAzureExporter,
            exportIntervalMillis: options.networkCollectionInterval || this._statsCollectionShortInterval, // 15 minutes
        };
        this._networkMetricReader = new sdkMetrics.PeriodicExportingMetricReader(networkMetricReaderOptions);
        this._networkStatsbeatMeterProvider.addMetricReader(this._networkMetricReader);
        this._networkStatsbeatMeter = this._networkStatsbeatMeterProvider.getMeter("Azure Monitor Network Statsbeat");
        this._endpointUrl = options.endpointUrl;
        this._runtimeVersion = process.version;
        this._language = STATSBEAT_LANGUAGE;
        this._version = packageVersion;
        this._host = this._getShortHost(options.endpointUrl);
        this._cikey = options.instrumentationKey;
        this._successCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.SUCCESS_COUNT);
        this._failureCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.FAILURE_COUNT);
        this._retryCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.RETRY_COUNT);
        this._throttleCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.THROTTLE_COUNT);
        this._exceptionCountGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.EXCEPTION_COUNT);
        this._averageDurationGauge = this._networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.AVERAGE_DURATION);
        this._commonProperties = {
            os: super._os,
            rp: super._resourceProvider,
            cikey: this._cikey,
            runtimeVersion: this._runtimeVersion,
            language: this._language,
            version: this._version,
            attach: this._attach,
        };
        this._networkProperties = {
            endpoint: this._endpointUrl,
            host: this._host,
        };
        this._isInitialized = true;
        this._initialize();
    }
    isInitialized() {
        return this._isInitialized;
    }
    shutdown() {
        this._networkStatsbeatMeterProvider.shutdown();
    }
    async _initialize() {
        try {
            await super._getResourceProvider();
            // Add network observable callbacks
            this._successCountGauge.addCallback(this._successCallback.bind(this));
            this._networkStatsbeatMeter.addBatchObservableCallback(this._failureCallback.bind(this), [
                this._failureCountGauge,
            ]);
            this._networkStatsbeatMeter.addBatchObservableCallback(this._retryCallback.bind(this), [
                this._retryCountGauge,
            ]);
            this._networkStatsbeatMeter.addBatchObservableCallback(this._throttleCallback.bind(this), [
                this._throttleCountGauge,
            ]);
            this._networkStatsbeatMeter.addBatchObservableCallback(this._exceptionCallback.bind(this), [
                this._exceptionCountGauge,
            ]);
            this._averageDurationGauge.addCallback(this._durationCallback.bind(this));
        }
        catch (error) {
            api.diag.debug("Call to get the resource provider failed.");
        }
    }
    // Observable gauge callbacks
    _successCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign({}, this._commonProperties), this._networkProperties);
        observableResult.observe(counter.totalSuccesfulRequestCount, attributes);
        counter.totalSuccesfulRequestCount = 0;
    }
    _failureCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        /*
          Takes the failureCountGauge, value (of the counter), and attributes
          create a unqiue counter based on statusCode as well
          append statusCode to attributes so the newly created attributes are unique.
        */
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { statusCode: 0 });
        // For each { statusCode -> count } mapping, call observe, passing the count and attributes that include the statusCode
        for (let i = 0; i < counter.totalFailedRequestCount.length; i++) {
            attributes.statusCode = counter.totalFailedRequestCount[i].statusCode;
            observableResult.observe(this._failureCountGauge, counter.totalFailedRequestCount[i].count, Object.assign({}, attributes));
            counter.totalFailedRequestCount[i].count = 0;
        }
    }
    _retryCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { statusCode: 0 });
        for (let i = 0; i < counter.retryCount.length; i++) {
            attributes.statusCode = counter.retryCount[i].statusCode;
            observableResult.observe(this._retryCountGauge, counter.retryCount[i].count, Object.assign({}, attributes));
            counter.retryCount[i].count = 0;
        }
    }
    _throttleCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { statusCode: 0 });
        for (let i = 0; i < counter.throttleCount.length; i++) {
            attributes.statusCode = counter.throttleCount[i].statusCode;
            observableResult.observe(this._throttleCountGauge, counter.throttleCount[i].count, Object.assign({}, attributes));
            counter.throttleCount[i].count = 0;
        }
    }
    _exceptionCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign(Object.assign({}, this._networkProperties), this._commonProperties), { exceptionType: "" });
        for (let i = 0; i < counter.exceptionCount.length; i++) {
            attributes.exceptionType = counter.exceptionCount[i].exceptionType;
            observableResult.observe(this._exceptionCountGauge, counter.exceptionCount[i].count, Object.assign({}, attributes));
            counter.exceptionCount[i].count = 0;
        }
    }
    _durationCallback(observableResult) {
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let attributes = Object.assign(Object.assign({}, this._networkProperties), this._commonProperties);
        for (let i = 0; i < this._networkStatsbeatCollection.length; i++) {
            let currentCounter = this._networkStatsbeatCollection[i];
            currentCounter.time = Number(new Date());
            let intervalRequests = currentCounter.totalRequestCount - currentCounter.lastRequestCount || 0;
            currentCounter.averageRequestExecutionTime =
                (currentCounter.intervalRequestExecutionTime -
                    currentCounter.lastIntervalRequestExecutionTime) /
                    intervalRequests || 0;
            currentCounter.lastIntervalRequestExecutionTime = currentCounter.intervalRequestExecutionTime; // reset
            currentCounter.lastRequestCount = currentCounter.totalRequestCount;
            currentCounter.lastTime = currentCounter.time;
        }
        observableResult.observe(counter.averageRequestExecutionTime, attributes);
        counter.averageRequestExecutionTime = 0;
    }
    // Public methods to increase counters
    countSuccess(duration) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        counter.totalRequestCount++;
        counter.totalSuccesfulRequestCount++;
        counter.intervalRequestExecutionTime += duration;
    }
    countFailure(duration, statusCode) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentStatusCounter = counter.totalFailedRequestCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.totalFailedRequestCount.push({ statusCode: statusCode, count: 1 });
        }
        counter.totalRequestCount++;
        counter.intervalRequestExecutionTime += duration;
    }
    countRetry(statusCode) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentStatusCounter = counter.retryCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.retryCount.push({ statusCode: statusCode, count: 1 });
        }
    }
    countThrottle(statusCode) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentStatusCounter = counter.throttleCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.throttleCount.push({ statusCode: statusCode, count: 1 });
        }
    }
    countException(exceptionType) {
        if (!this._isInitialized) {
            return;
        }
        let counter = this._getNetworkStatsbeatCounter(this._endpointUrl, this._host);
        let currentErrorCounter = counter.exceptionCount.find((exceptionCounter) => exceptionType.name === exceptionCounter.exceptionType);
        if (currentErrorCounter) {
            currentErrorCounter.count++;
        }
        else {
            counter.exceptionCount.push({ exceptionType: exceptionType.name, count: 1 });
        }
    }
    // Gets a networkStatsbeat counter if one exists for the given endpoint
    _getNetworkStatsbeatCounter(endpoint, host) {
        // Check if the counter is available
        for (let i = 0; i < this._networkStatsbeatCollection.length; i++) {
            // Same object
            if (endpoint === this._networkStatsbeatCollection[i].endpoint &&
                host === this._networkStatsbeatCollection[i].host) {
                return this._networkStatsbeatCollection[i];
            }
        }
        // Create a new counter if not found
        let newCounter = new NetworkStatsbeat(endpoint, host);
        this._networkStatsbeatCollection.push(newCounter);
        return newCounter;
    }
    _getShortHost(originalHost) {
        let shortHost = originalHost;
        try {
            let hostRegex = new RegExp(/^https?:\/\/(?:www\.)?([^\/.-]+)/);
            let res = hostRegex.exec(originalHost);
            if (res != null && res.length > 1) {
                shortHost = res[1];
            }
            shortHost = shortHost.replace(".in.applicationinsights.azure.com", "");
        }
        catch (error) {
            api.diag.debug("Failed to get the short host name.");
        }
        return shortHost;
    }
}

// Copyright (c) Microsoft Corporation.
let instance = null;
/**
 * Long Interval Statsbeat Metrics
 * @internal
 */
class LongIntervalStatsbeatMetrics extends StatsbeatMetrics {
    constructor(options) {
        super();
        this._AZURE_MONITOR_STATSBEAT_FEATURES = process.env.AZURE_MONITOR_STATSBEAT_FEATURES;
        this._statsCollectionLongInterval = 86400000; // 1 day
        this._isInitialized = false;
        this._attach = "sdk";
        this._feature = 0;
        this._instrumentation = 0;
        this._connectionString = super._getConnectionString(options.endpointUrl);
        const exporterConfig = {
            connectionString: this._connectionString,
        };
        if (this._AZURE_MONITOR_STATSBEAT_FEATURES) {
            try {
                this._feature = JSON.parse(this._AZURE_MONITOR_STATSBEAT_FEATURES).feature;
                this._instrumentation = JSON.parse(this._AZURE_MONITOR_STATSBEAT_FEATURES).instrumentation;
            }
            catch (error) {
                api.diag.error(`LongIntervalStatsbeat: Failed to parse features/instrumentations (error ${error})`);
            }
        }
        this._longIntervalStatsbeatMeterProvider = new sdkMetrics.MeterProvider();
        this._longIntervalAzureExporter = new AzureMonitorStatsbeatExporter(exporterConfig);
        // Export Long Interval Statsbeats every day
        const longIntervalMetricReaderOptions = {
            exporter: this._longIntervalAzureExporter,
            exportIntervalMillis: Number(process.env.LONG_INTERVAL_EXPORT_MILLIS) || this._statsCollectionLongInterval, // 1 day
        };
        this._longIntervalMetricReader = new sdkMetrics.PeriodicExportingMetricReader(longIntervalMetricReaderOptions);
        this._longIntervalStatsbeatMeterProvider.addMetricReader(this._longIntervalMetricReader);
        this._longIntervalStatsbeatMeter = this._longIntervalStatsbeatMeterProvider.getMeter("Azure Monitor Long Interval Statsbeat");
        // Assign Common Properties
        this._runtimeVersion = process.version;
        this._language = STATSBEAT_LANGUAGE;
        this._version = packageVersion;
        this._cikey = options.instrumentationKey;
        this._featureStatsbeatGauge = this._longIntervalStatsbeatMeter.createObservableGauge(StatsbeatCounter.FEATURE);
        this._attachStatsbeatGauge = this._longIntervalStatsbeatMeter.createObservableGauge(StatsbeatCounter.ATTACH);
        this._commonProperties = {
            os: super._os,
            rp: super._resourceProvider,
            cikey: this._cikey,
            runtimeVersion: this._runtimeVersion,
            language: this._language,
            version: this._version,
            attach: this._attach,
        };
        this._attachProperties = {
            rpId: super._resourceIdentifier,
        };
        this._isInitialized = true;
        this._initialize();
    }
    async _initialize() {
        try {
            await this._getResourceProvider();
            // Add long interval observable callbacks
            this._attachStatsbeatGauge.addCallback(this._attachCallback.bind(this));
            this._longIntervalStatsbeatMeter.addBatchObservableCallback(this._featureCallback.bind(this), [this._featureStatsbeatGauge]);
            // Export Feature/Attach Statsbeat once upon app initialization
            this._longIntervalAzureExporter.export((await this._longIntervalMetricReader.collect()).resourceMetrics, (result) => {
                if (result.code !== core.ExportResultCode.SUCCESS) {
                    api.diag.error(`LongIntervalStatsbeat: metrics export failed (error ${result.error})`);
                }
            });
        }
        catch (error) {
            api.diag.debug("Call to get the resource provider failed.");
        }
    }
    _featureCallback(observableResult) {
        let attributes;
        if (this._instrumentation) {
            attributes = Object.assign(Object.assign({}, this._commonProperties), { feature: this._instrumentation, type: StatsbeatFeatureType.INSTRUMENTATION });
            observableResult.observe(this._featureStatsbeatGauge, 1, Object.assign({}, attributes));
        }
        if (this._feature) {
            attributes = Object.assign(Object.assign({}, this._commonProperties), { feature: this._feature, type: StatsbeatFeatureType.FEATURE });
            observableResult.observe(this._featureStatsbeatGauge, 1, Object.assign({}, attributes));
        }
    }
    _attachCallback(observableResult) {
        let attributes = Object.assign(Object.assign({}, this._commonProperties), this._attachProperties);
        observableResult.observe(1, attributes);
    }
    isInitialized() {
        return this._isInitialized;
    }
    shutdown() {
        this._longIntervalStatsbeatMeterProvider.shutdown();
    }
}
/**
 * Singleton LongIntervalStatsbeatMetrics instance.
 * @internal
 */
function getInstance(options) {
    if (!instance) {
        instance = new LongIntervalStatsbeatMetrics(options);
    }
    return instance;
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS = 60000;
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
class AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorBaseExporter class.
     * @param AzureMonitorExporterOptions - Exporter configuration.
     */
    constructor(options = {}, isStatsbeatExporter) {
        var _a;
        /**
         * Instrumentation key to be used for exported envelopes
         */
        this._instrumentationKey = "";
        this._endpointUrl = "";
        this._statsbeatFailureCount = 0;
        this._batchSendRetryIntervalMs = DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS;
        this._options = options;
        this._numConsecutiveRedirects = 0;
        this._instrumentationKey = "";
        this._endpointUrl = DEFAULT_BREEZE_ENDPOINT;
        const connectionString = this._options.connectionString || process.env[ENV_CONNECTION_STRING];
        this._isStatsbeatExporter = isStatsbeatExporter ? isStatsbeatExporter : false;
        if (connectionString) {
            const parsedConnectionString = ConnectionStringParser.parse(connectionString);
            this._instrumentationKey =
                parsedConnectionString.instrumentationkey || this._instrumentationKey;
            this._endpointUrl = ((_a = parsedConnectionString.ingestionendpoint) === null || _a === void 0 ? void 0 : _a.trim()) || this._endpointUrl;
        }
        // Instrumentation key is required
        if (!this._instrumentationKey) {
            const message = "No instrumentation key or connection string was provided to the Azure Monitor Exporter";
            api.diag.error(message);
            throw new Error(message);
        }
        this._sender = new HttpSender(this._endpointUrl, this._options);
        this._persister = new FileSystemPersist(this._instrumentationKey, this._options);
        if (!this._isStatsbeatExporter && !process.env[ENV_DISABLE_STATSBEAT]) {
            // Initialize statsbeatMetrics
            this._networkStatsbeatMetrics = new NetworkStatsbeatMetrics({
                instrumentationKey: this._instrumentationKey,
                endpointUrl: this._endpointUrl,
            });
            this._longIntervalStatsbeatMetrics = getInstance({
                instrumentationKey: this._instrumentationKey,
                endpointUrl: this._endpointUrl,
            });
        }
        this._retryTimer = null;
        api.diag.debug("AzureMonitorExporter was successfully setup");
    }
    /**
     * Persist envelopes to disk
     */
    async _persist(envelopes) {
        try {
            const success = await this._persister.push(envelopes);
            return success
                ? { code: core.ExportResultCode.SUCCESS }
                : {
                    code: core.ExportResultCode.FAILED,
                    error: new Error("Failed to persist envelope in disk."),
                };
        }
        catch (ex) {
            return { code: core.ExportResultCode.FAILED, error: ex };
        }
    }
    /**
     * Shutdown exporter
     */
    async _shutdown() {
        return this._sender.shutdown();
    }
    /**
     * Export envelopes
     */
    async _exportEnvelopes(envelopes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        api.diag.info(`Exporting ${envelopes.length} envelope(s)`);
        if (envelopes.length < 1) {
            return { code: core.ExportResultCode.SUCCESS };
        }
        try {
            const startTime = new Date().getTime();
            const { result, statusCode } = await this._sender.send(envelopes);
            const endTime = new Date().getTime();
            const duration = endTime - startTime;
            this._numConsecutiveRedirects = 0;
            if (statusCode === 200) {
                // Success -- @todo: start retry timer
                if (!this._retryTimer) {
                    this._retryTimer = setTimeout(() => {
                        this._retryTimer = null;
                        this._sendFirstPersistedFile();
                    }, this._batchSendRetryIntervalMs);
                    this._retryTimer.unref();
                }
                // If we are not exportings statsbeat and statsbeat is not disabled -- count success
                (_a = this._networkStatsbeatMetrics) === null || _a === void 0 ? void 0 : _a.countSuccess(duration);
                return { code: core.ExportResultCode.SUCCESS };
            }
            else if (statusCode && isRetriable(statusCode)) {
                // Failed -- persist failed data
                if (statusCode === 429 || statusCode === 439) {
                    (_b = this._networkStatsbeatMetrics) === null || _b === void 0 ? void 0 : _b.countThrottle(statusCode);
                }
                if (result) {
                    api.diag.info(result);
                    const breezeResponse = JSON.parse(result);
                    const filteredEnvelopes = [];
                    if (breezeResponse.errors) {
                        breezeResponse.errors.forEach((error) => {
                            if (error.statusCode && isRetriable(error.statusCode)) {
                                filteredEnvelopes.push(envelopes[error.index]);
                            }
                        });
                    }
                    if (filteredEnvelopes.length > 0) {
                        (_c = this._networkStatsbeatMetrics) === null || _c === void 0 ? void 0 : _c.countRetry(statusCode);
                        // calls resultCallback(ExportResult) based on result of persister.push
                        return await this._persist(filteredEnvelopes);
                    }
                    // Failed -- not retriable
                    (_d = this._networkStatsbeatMetrics) === null || _d === void 0 ? void 0 : _d.countFailure(duration, statusCode);
                    return {
                        code: core.ExportResultCode.FAILED,
                    };
                }
                else {
                    // calls resultCallback(ExportResult) based on result of persister.push
                    (_e = this._networkStatsbeatMetrics) === null || _e === void 0 ? void 0 : _e.countRetry(statusCode);
                    return await this._persist(envelopes);
                }
            }
            else {
                // Failed -- not retriable
                if (this._networkStatsbeatMetrics) {
                    if (statusCode) {
                        this._networkStatsbeatMetrics.countFailure(duration, statusCode);
                    }
                }
                else {
                    this._incrementStatsbeatFailure();
                }
                return {
                    code: core.ExportResultCode.FAILED,
                };
            }
        }
        catch (error) {
            const restError = error;
            if (restError.statusCode &&
                (restError.statusCode === 307 || // Temporary redirect
                    restError.statusCode === 308)) {
                // Permanent redirect
                this._numConsecutiveRedirects++;
                // To prevent circular redirects
                if (this._numConsecutiveRedirects < 10) {
                    if (restError.response && restError.response.headers) {
                        const location = restError.response.headers.get("location");
                        if (location) {
                            // Update sender URL
                            this._sender.handlePermanentRedirect(location);
                            // Send to redirect endpoint as HTTPs library doesn't handle redirect automatically
                            return this._exportEnvelopes(envelopes);
                        }
                    }
                }
                else {
                    let redirectError = new Error("Circular redirect");
                    (_f = this._networkStatsbeatMetrics) === null || _f === void 0 ? void 0 : _f.countException(redirectError);
                    return { code: core.ExportResultCode.FAILED, error: redirectError };
                }
            }
            else if (restError.statusCode && isRetriable(restError.statusCode)) {
                (_g = this._networkStatsbeatMetrics) === null || _g === void 0 ? void 0 : _g.countRetry(restError.statusCode);
                return await this._persist(envelopes);
            }
            if (this._isNetworkError(restError)) {
                if (restError.statusCode) {
                    (_h = this._networkStatsbeatMetrics) === null || _h === void 0 ? void 0 : _h.countRetry(restError.statusCode);
                }
                api.diag.error("Retrying due to transient client side error. Error message:", restError.message);
                return await this._persist(envelopes);
            }
            (_j = this._networkStatsbeatMetrics) === null || _j === void 0 ? void 0 : _j.countException(restError);
            api.diag.error("Envelopes could not be exported and are not retriable. Error message:", restError.message);
            return { code: core.ExportResultCode.FAILED, error: restError };
        }
    }
    // Disable collection of statsbeat metrics after max failures
    _incrementStatsbeatFailure() {
        var _a, _b;
        this._statsbeatFailureCount++;
        if (this._statsbeatFailureCount > MAX_STATSBEAT_FAILURES) {
            this._isStatsbeatExporter = false;
            (_a = this._networkStatsbeatMetrics) === null || _a === void 0 ? void 0 : _a.shutdown();
            (_b = this._longIntervalStatsbeatMetrics) === null || _b === void 0 ? void 0 : _b.shutdown();
            this._networkStatsbeatMetrics = undefined;
            this._statsbeatFailureCount = 0;
        }
    }
    async _sendFirstPersistedFile() {
        try {
            const envelopes = (await this._persister.shift());
            if (envelopes) {
                await this._sender.send(envelopes);
            }
        }
        catch (err) {
            api.diag.warn(`Failed to fetch persisted file`, err);
        }
    }
    _isNetworkError(error) {
        if (error && error.code && error.code === "REQUEST_SEND_ERROR") {
            return true;
        }
        return false;
    }
}

// Copyright (c) Microsoft Corporation.
function createTagsFromResource(resource) {
    const context = getInstance$1();
    const tags = Object.assign({}, context.tags);
    if (resource && resource.attributes) {
        tags[KnownContextTagKeys.AiCloudRole] = getCloudRole(resource);
        tags[KnownContextTagKeys.AiCloudRoleInstance] = getCloudRoleInstance(resource);
        const endUserId = resource.attributes[semanticConventions.SemanticAttributes.ENDUSER_ID];
        if (endUserId) {
            tags[KnownContextTagKeys.AiUserId] = String(endUserId);
        }
    }
    return tags;
}
function getCloudRole(resource) {
    let cloudRole = "";
    // Service attributes
    const serviceName = resource.attributes[semanticConventions.SemanticResourceAttributes.SERVICE_NAME];
    const serviceNamespace = resource.attributes[semanticConventions.SemanticResourceAttributes.SERVICE_NAMESPACE];
    if (serviceName) {
        // Custom Service name provided by customer is highest precedence
        if (!String(serviceName).startsWith("unknown_service")) {
            if (serviceNamespace) {
                return `${serviceNamespace}.${serviceName}`;
            }
            else {
                return String(serviceName);
            }
        }
        else {
            // Service attributes will be only used if K8S attributes are not present
            if (serviceNamespace) {
                cloudRole = `${serviceNamespace}.${serviceName}`;
            }
            else {
                cloudRole = String(serviceName);
            }
        }
    }
    // Kubernetes attributes should take precedence
    const kubernetesDeploymentName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_DEPLOYMENT_NAME];
    if (kubernetesDeploymentName) {
        return String(kubernetesDeploymentName);
    }
    const kuberneteReplicasetName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_REPLICASET_NAME];
    if (kuberneteReplicasetName) {
        return String(kuberneteReplicasetName);
    }
    const kubernetesStatefulSetName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_STATEFULSET_NAME];
    if (kubernetesStatefulSetName) {
        return String(kubernetesStatefulSetName);
    }
    const kubernetesJobName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_JOB_NAME];
    if (kubernetesJobName) {
        return String(kubernetesJobName);
    }
    const kubernetesCronjobName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_CRONJOB_NAME];
    if (kubernetesCronjobName) {
        return String(kubernetesCronjobName);
    }
    const kubernetesDaemonsetName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_DAEMONSET_NAME];
    if (kubernetesDaemonsetName) {
        return String(kubernetesDaemonsetName);
    }
    return cloudRole;
}
function getCloudRoleInstance(resource) {
    // Kubernetes attributes should take precedence
    const kubernetesPodName = resource.attributes[semanticConventions.SemanticResourceAttributes.K8S_POD_NAME];
    if (kubernetesPodName) {
        return String(kubernetesPodName);
    }
    // Service attributes
    const serviceInstanceId = resource.attributes[semanticConventions.SemanticResourceAttributes.SERVICE_INSTANCE_ID];
    if (serviceInstanceId) {
        return String(serviceInstanceId);
    }
    // Default
    return os__default["default"] && os__default["default"].hostname();
}
function isSqlDB(dbSystem) {
    return (dbSystem === semanticConventions.DbSystemValues.DB2 ||
        dbSystem === semanticConventions.DbSystemValues.DERBY ||
        dbSystem === semanticConventions.DbSystemValues.MARIADB ||
        dbSystem === semanticConventions.DbSystemValues.MSSQL ||
        dbSystem === semanticConventions.DbSystemValues.ORACLE ||
        dbSystem === semanticConventions.DbSystemValues.SQLITE ||
        dbSystem === semanticConventions.DbSystemValues.OTHER_SQL ||
        dbSystem === semanticConventions.DbSystemValues.HSQLDB ||
        dbSystem === semanticConventions.DbSystemValues.H2);
}
function getUrl(attributes) {
    if (!attributes) {
        return "";
    }
    const httpMethod = attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
    if (httpMethod) {
        const httpUrl = attributes[semanticConventions.SemanticAttributes.HTTP_URL];
        if (httpUrl) {
            return String(httpUrl);
        }
        else {
            const httpScheme = attributes[semanticConventions.SemanticAttributes.HTTP_SCHEME];
            const httpTarget = attributes[semanticConventions.SemanticAttributes.HTTP_TARGET];
            if (httpScheme && httpTarget) {
                const httpHost = attributes[semanticConventions.SemanticAttributes.HTTP_HOST];
                if (httpHost) {
                    return `${httpScheme}://${httpHost}${httpTarget}`;
                }
                else {
                    const netPeerPort = attributes[semanticConventions.SemanticAttributes.NET_PEER_PORT];
                    if (netPeerPort) {
                        const netPeerName = attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME];
                        if (netPeerName) {
                            return `${httpScheme}://${netPeerName}:${netPeerPort}${httpTarget}`;
                        }
                        else {
                            const netPeerIp = attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
                            if (netPeerIp) {
                                return `${httpScheme}://${netPeerIp}:${netPeerPort}${httpTarget}`;
                            }
                        }
                    }
                }
            }
        }
    }
    return "";
}
function getDependencyTarget(attributes) {
    if (!attributes) {
        return "";
    }
    const peerService = attributes[semanticConventions.SemanticAttributes.PEER_SERVICE];
    const httpHost = attributes[semanticConventions.SemanticAttributes.HTTP_HOST];
    const httpUrl = attributes[semanticConventions.SemanticAttributes.HTTP_URL];
    const netPeerName = attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME];
    const netPeerIp = attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
    if (peerService) {
        return String(peerService);
    }
    else if (httpHost) {
        return String(httpHost);
    }
    else if (httpUrl) {
        return String(httpUrl);
    }
    else if (netPeerName) {
        return String(netPeerName);
    }
    else if (netPeerIp) {
        return String(netPeerIp);
    }
    return "";
}
function createResourceMetricEnvelope(resource, instrumentationKey) {
    if (resource && resource.attributes) {
        const tags = createTagsFromResource(resource);
        const resourceAttributes = {};
        for (const key of Object.keys(resource.attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key == semanticConventions.SemanticResourceAttributes.TELEMETRY_SDK_VERSION ||
                key == semanticConventions.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE ||
                key == semanticConventions.SemanticResourceAttributes.TELEMETRY_SDK_NAME)) {
                resourceAttributes[key] = resource.attributes[key];
            }
        }
        // Only send event when resource attributes are available
        if (Object.keys(resourceAttributes).length > 0) {
            let baseData = {
                version: 2,
                metrics: [{ name: "_APPRESOURCEPREVIEW_", value: 1 }],
                properties: resourceAttributes,
            };
            let envelope = {
                name: "Microsoft.ApplicationInsights.Metric",
                time: new Date(),
                sampleRate: 100,
                instrumentationKey: instrumentationKey,
                version: 1,
                data: {
                    baseType: "MetricData",
                    baseData: baseData,
                },
                tags: tags,
            };
            return envelope;
        }
    }
    return;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure SDK namespace.
 * @internal
 */
const AzNamespace = "az.namespace";
/**
 * Azure SDK Eventhub.
 * @internal
 */
const MicrosoftEventHub = "Microsoft.EventHub";
/**
 * Azure SDK message bus destination.
 * @internal
 */
const MessageBusDestination = "message_bus.destination";

// Copyright (c) Microsoft Corporation.
/**
 * Average span.links[].attributes.enqueuedTime
 */
const getTimeSinceEnqueued = (span) => {
    let countEnqueueDiffs = 0;
    let sumEnqueueDiffs = 0;
    const startTimeMs = core.hrTimeToMilliseconds(span.startTime);
    span.links.forEach(({ attributes }) => {
        const enqueuedTime = attributes === null || attributes === void 0 ? void 0 : attributes[ENQUEUED_TIME];
        if (enqueuedTime) {
            countEnqueueDiffs += 1;
            sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0);
        }
    });
    return Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);
};
/**
 * Implementation of Mapping to Azure Monitor
 *
 * https://gist.github.com/lmolkova/e4215c0f44a49ef824983382762e6b92#mapping-to-azure-monitor-application-insights-telemetry
 * @internal
 */
const parseEventHubSpan = (span, baseData) => {
    const namespace = span.attributes[AzNamespace];
    const peerAddress = (span.attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME] ||
        span.attributes["peer.address"] ||
        "unknown").replace(/\/$/g, ""); // remove trailing "/"
    const messageBusDestination = (span.attributes[MessageBusDestination] || "unknown");
    switch (span.kind) {
        case api.SpanKind.CLIENT:
            baseData.type = namespace;
            baseData.target = `${peerAddress}/${messageBusDestination}`;
            break;
        case api.SpanKind.PRODUCER:
            baseData.type = `Queue Message | ${namespace}`;
            baseData.target = `${peerAddress}/${messageBusDestination}`;
            break;
        case api.SpanKind.CONSUMER:
            baseData.type = `Queue Message | ${namespace}`;
            baseData.source = `${peerAddress}/${messageBusDestination}`;
            baseData.measurements = Object.assign(Object.assign({}, baseData.measurements), { [TIME_SINCE_ENQUEUED]: getTimeSinceEnqueued(span) });
            break;
    }
};

// Copyright (c) Microsoft Corporation.
function createTagsFromSpan(span) {
    const tags = createTagsFromResource(span.resource);
    tags[KnownContextTagKeys.AiOperationId] = span.spanContext().traceId;
    if (span.parentSpanId) {
        tags[KnownContextTagKeys.AiOperationParentId] = span.parentSpanId;
    }
    const httpUserAgent = span.attributes[semanticConventions.SemanticAttributes.HTTP_USER_AGENT];
    if (httpUserAgent) {
        // TODO: Not exposed in Swagger, need to update def
        tags["ai.user.userAgent"] = String(httpUserAgent);
    }
    if (span.kind === api.SpanKind.SERVER) {
        const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
        const httpClientIp = span.attributes[semanticConventions.SemanticAttributes.HTTP_CLIENT_IP];
        const netPeerIp = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
        if (httpMethod) {
            const httpRoute = span.attributes[semanticConventions.SemanticAttributes.HTTP_ROUTE];
            const httpUrl = span.attributes[semanticConventions.SemanticAttributes.HTTP_URL];
            tags[KnownContextTagKeys.AiOperationName] = span.name; // Default
            if (httpRoute) {
                tags[KnownContextTagKeys.AiOperationName] = `${httpMethod} ${httpRoute}`;
            }
            else if (httpUrl) {
                try {
                    const url$1 = new url.URL(String(httpUrl));
                    tags[KnownContextTagKeys.AiOperationName] = `${httpMethod} ${url$1.pathname}`;
                }
                catch (ex) { }
            }
            if (httpClientIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(httpClientIp);
            }
            else if (netPeerIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(netPeerIp);
            }
        }
        else {
            tags[KnownContextTagKeys.AiOperationName] = span.name;
            if (netPeerIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(netPeerIp);
            }
        }
    }
    // TODO: Operation Name and Location IP TBD for non server spans
    return tags;
}
function createPropertiesFromSpanAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key == semanticConventions.SemanticAttributes.NET_PEER_IP ||
                key == semanticConventions.SemanticAttributes.NET_PEER_NAME ||
                key == semanticConventions.SemanticAttributes.PEER_SERVICE ||
                key == semanticConventions.SemanticAttributes.HTTP_METHOD ||
                key == semanticConventions.SemanticAttributes.HTTP_URL ||
                key == semanticConventions.SemanticAttributes.HTTP_STATUS_CODE ||
                key == semanticConventions.SemanticAttributes.HTTP_ROUTE ||
                key == semanticConventions.SemanticAttributes.HTTP_HOST ||
                key == semanticConventions.SemanticAttributes.HTTP_URL ||
                key == semanticConventions.SemanticAttributes.DB_SYSTEM ||
                key == semanticConventions.SemanticAttributes.DB_STATEMENT ||
                key == semanticConventions.SemanticAttributes.DB_OPERATION ||
                key == semanticConventions.SemanticAttributes.DB_NAME ||
                key == semanticConventions.SemanticAttributes.RPC_SYSTEM ||
                key == semanticConventions.SemanticAttributes.RPC_GRPC_STATUS_CODE)) {
                properties[key] = attributes[key];
            }
        }
    }
    return properties;
}
function createPropertiesFromSpan(span) {
    const properties = createPropertiesFromSpanAttributes(span.attributes);
    const measurements = {};
    const links = span.links.map((link) => ({
        operation_Id: link.context.traceId,
        id: link.context.spanId,
    }));
    if (links.length > 0) {
        properties[MS_LINKS] = JSON.stringify(links);
    }
    return [properties, measurements];
}
function createDependencyData(span) {
    const remoteDependencyData = {
        name: span.name,
        id: `${span.spanContext().spanId}`,
        success: span.status.code != api.SpanStatusCode.ERROR,
        resultCode: "0",
        type: "Dependency",
        duration: msToTimeSpan(core.hrTimeToMilliseconds(span.duration)),
        version: 2,
    };
    if (span.kind === api.SpanKind.PRODUCER) {
        remoteDependencyData.type = DependencyTypes.QueueMessage;
    }
    if (span.kind === api.SpanKind.INTERNAL && span.parentSpanId) {
        remoteDependencyData.type = DependencyTypes.InProc;
    }
    const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
    const dbSystem = span.attributes[semanticConventions.SemanticAttributes.DB_SYSTEM];
    const rpcSystem = span.attributes[semanticConventions.SemanticAttributes.RPC_SYSTEM];
    // HTTP Dependency
    if (httpMethod) {
        const httpUrl = span.attributes[semanticConventions.SemanticAttributes.HTTP_URL];
        if (httpUrl) {
            try {
                const dependencyUrl = new url.URL(String(httpUrl));
                remoteDependencyData.name = `${httpMethod} ${dependencyUrl.pathname}`;
            }
            catch (ex) { }
        }
        remoteDependencyData.type = DependencyTypes.Http;
        remoteDependencyData.data = getUrl(span.attributes);
        const httpStatusCode = span.attributes[semanticConventions.SemanticAttributes.HTTP_STATUS_CODE];
        if (httpStatusCode) {
            remoteDependencyData.resultCode = String(httpStatusCode);
        }
        let target = getDependencyTarget(span.attributes);
        if (target) {
            try {
                // Remove default port
                const portRegex = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/);
                const res = portRegex.exec(target);
                if (res != null) {
                    const protocol = res[1];
                    const port = res[3];
                    if ((protocol == "https" && port == ":443") || (protocol == "http" && port == ":80")) {
                        // Drop port
                        target = res[1] + res[2] + res[4];
                    }
                }
            }
            catch (ex) { }
            remoteDependencyData.target = `${target}`;
        }
    }
    // DB Dependency
    else if (dbSystem) {
        // TODO: Remove special logic when Azure UX supports OpenTelemetry dbSystem
        if (String(dbSystem) === semanticConventions.DbSystemValues.MYSQL) {
            remoteDependencyData.type = "mysql";
        }
        else if (String(dbSystem) === semanticConventions.DbSystemValues.POSTGRESQL) {
            remoteDependencyData.type = "postgresql";
        }
        else if (String(dbSystem) === semanticConventions.DbSystemValues.MONGODB) {
            remoteDependencyData.type = "mongodb";
        }
        else if (String(dbSystem) === semanticConventions.DbSystemValues.REDIS) {
            remoteDependencyData.type = "redis";
        }
        else if (isSqlDB(String(dbSystem))) {
            remoteDependencyData.type = "SQL";
        }
        else {
            remoteDependencyData.type = String(dbSystem);
        }
        const dbStatement = span.attributes[semanticConventions.SemanticAttributes.DB_STATEMENT];
        const dbOperation = span.attributes[semanticConventions.SemanticAttributes.DB_OPERATION];
        if (dbStatement) {
            remoteDependencyData.data = String(dbStatement);
        }
        else if (dbOperation) {
            remoteDependencyData.data = String(dbOperation);
        }
        const target = getDependencyTarget(span.attributes);
        const dbName = span.attributes[semanticConventions.SemanticAttributes.DB_NAME];
        if (target) {
            remoteDependencyData.target = dbName ? `${target}|${dbName}` : `${target}`;
        }
        else {
            remoteDependencyData.target = dbName ? `${dbName}` : `${dbSystem}`;
        }
    }
    // grpc Dependency
    else if (rpcSystem) {
        remoteDependencyData.type = DependencyTypes.Grpc;
        const grpcStatusCode = span.attributes[semanticConventions.SemanticAttributes.RPC_GRPC_STATUS_CODE];
        if (grpcStatusCode) {
            remoteDependencyData.resultCode = String(grpcStatusCode);
        }
        const target = getDependencyTarget(span.attributes);
        if (target) {
            remoteDependencyData.target = `${target}`;
        }
        else if (rpcSystem) {
            remoteDependencyData.target = String(rpcSystem);
        }
    }
    return remoteDependencyData;
}
function createRequestData(span) {
    const requestData = {
        id: `${span.spanContext().spanId}`,
        success: span.status.code != api.SpanStatusCode.ERROR,
        responseCode: "0",
        duration: msToTimeSpan(core.hrTimeToMilliseconds(span.duration)),
        version: 2,
        source: undefined,
    };
    const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
    const grpcStatusCode = span.attributes[semanticConventions.SemanticAttributes.RPC_GRPC_STATUS_CODE];
    if (httpMethod) {
        requestData.url = getUrl(span.attributes);
        const httpStatusCode = span.attributes[semanticConventions.SemanticAttributes.HTTP_STATUS_CODE];
        if (httpStatusCode) {
            requestData.responseCode = String(httpStatusCode);
        }
    }
    else if (grpcStatusCode) {
        requestData.responseCode = String(grpcStatusCode);
    }
    return requestData;
}
/**
 * Span to Azure envelope parsing.
 * @internal
 */
function readableSpanToEnvelope(span, ikey) {
    let name;
    let baseType;
    let baseData;
    const time = new Date(core.hrTimeToMilliseconds(span.startTime));
    const instrumentationKey = ikey;
    const tags = createTagsFromSpan(span);
    const [properties, measurements] = createPropertiesFromSpan(span);
    switch (span.kind) {
        case api.SpanKind.CLIENT:
        case api.SpanKind.PRODUCER:
        case api.SpanKind.INTERNAL:
            name = "Microsoft.ApplicationInsights.RemoteDependency";
            baseType = "RemoteDependencyData";
            baseData = createDependencyData(span);
            break;
        case api.SpanKind.SERVER:
        case api.SpanKind.CONSUMER:
            name = "Microsoft.ApplicationInsights.Request";
            baseType = "RequestData";
            baseData = createRequestData(span);
            baseData.name = tags[KnownContextTagKeys.AiOperationName];
            break;
        default:
            // never
            api.diag.error(`Unsupported span kind ${span.kind}`);
            throw new Error(`Unsupported span kind ${span.kind}`);
    }
    let sampleRate = 100;
    if (span.attributes[AzureMonitorSampleRate]) {
        sampleRate = Number(span.attributes[AzureMonitorSampleRate]);
    }
    // Azure SDK
    if (span.attributes[AzNamespace]) {
        if (span.kind === api.SpanKind.INTERNAL) {
            baseData.type = `${DependencyTypes.InProc} | ${span.attributes[AzNamespace]}`;
        }
        if (span.attributes[AzNamespace] === MicrosoftEventHub) {
            parseEventHubSpan(span, baseData);
        }
    }
    return {
        name,
        sampleRate,
        time,
        instrumentationKey,
        tags,
        version: 1,
        data: {
            baseType,
            baseData: Object.assign(Object.assign({}, baseData), { properties,
                measurements }),
        },
    };
}
/**
 * Span Events to Azure envelopes parsing.
 * @internal
 */
function spanEventsToEnvelopes(span, ikey) {
    const envelopes = [];
    if (span.events) {
        span.events.forEach((event) => {
            var _a;
            let baseType;
            const time = new Date(core.hrTimeToMilliseconds(event.time));
            let name = "";
            let baseData;
            const properties = createPropertiesFromSpanAttributes(event.attributes);
            const tags = createTagsFromResource(span.resource);
            tags[KnownContextTagKeys.AiOperationId] = span.spanContext().traceId;
            const spanId = (_a = span.spanContext()) === null || _a === void 0 ? void 0 : _a.spanId;
            if (spanId) {
                tags[KnownContextTagKeys.AiOperationParentId] = spanId;
            }
            // Only generate exception telemetry for incoming requests
            if (event.name == "exception" && span.kind == api.SpanKind.SERVER) {
                name = "Microsoft.ApplicationInsights.Exception";
                baseType = "ExceptionData";
                let typeName = "";
                let message = "Exception";
                let stack = "";
                let hasFullStack = false;
                if (event.attributes) {
                    typeName = String(event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_TYPE]);
                    stack = String(event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_STACKTRACE]);
                    if (stack) {
                        hasFullStack = true;
                    }
                    const exceptionMsg = event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_MESSAGE];
                    if (exceptionMsg) {
                        message = String(exceptionMsg);
                    }
                    const escaped = event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_ESCAPED];
                    if (escaped != undefined) {
                        properties[semanticConventions.SemanticAttributes.EXCEPTION_ESCAPED] = String(escaped);
                    }
                }
                const exceptionDetails = {
                    typeName: typeName,
                    message: message,
                    stack: stack,
                    hasFullStack: hasFullStack,
                };
                const exceptionData = {
                    exceptions: [exceptionDetails],
                    version: 2,
                    properties: properties,
                };
                baseData = exceptionData;
            }
            else {
                name = "Microsoft.ApplicationInsights.Message";
                baseType = "MessageData";
                const messageData = {
                    message: event.name,
                    version: 2,
                    properties: properties,
                };
                baseData = messageData;
            }
            let sampleRate = 100;
            if (span.attributes[AzureMonitorSampleRate]) {
                sampleRate = Number(span.attributes[AzureMonitorSampleRate]);
            }
            const env = {
                name: name,
                time: time,
                instrumentationKey: ikey,
                version: 1,
                sampleRate: sampleRate,
                data: {
                    baseType: baseType,
                    baseData: baseData,
                },
                tags: tags,
            };
            envelopes.push(env);
        });
    }
    return envelopes;
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
class AzureMonitorTraceExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorTraceExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Flag to determine if Exporter is shutdown.
         */
        this._isShutdown = false;
        api.diag.debug("AzureMonitorTraceExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry spans.
     * @param spans - Spans to export.
     * @param resultCallback - Result callback.
     */
    async export(spans, resultCallback) {
        if (this._isShutdown) {
            api.diag.info("Exporter shut down. Failed to export spans.");
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        api.diag.info(`Exporting ${spans.length} span(s). Converting to envelopes...`);
        if (spans.length > 0) {
            let envelopes = [];
            const resourceMetricEnvelope = createResourceMetricEnvelope(spans[0].resource, this._instrumentationKey);
            if (resourceMetricEnvelope) {
                envelopes.push(resourceMetricEnvelope);
            }
            spans.forEach((span) => {
                envelopes.push(readableSpanToEnvelope(span, this._instrumentationKey));
                let spanEventEnvelopes = spanEventsToEnvelopes(span, this._instrumentationKey);
                if (spanEventEnvelopes.length > 0) {
                    envelopes.push(...spanEventEnvelopes);
                }
            });
            resultCallback(await this._exportEnvelopes(envelopes));
        }
        // No data to export
        resultCallback({ code: core.ExportResultCode.SUCCESS });
    }
    /**
     * Shutdown AzureMonitorTraceExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        api.diag.info("AzureMonitorTraceExporter shutting down");
        return this._shutdown();
    }
}

// Copyright (c) Microsoft Corporation.
function createPropertiesFromMetricAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            properties[key] = attributes[key];
        }
    }
    return properties;
}
/**
 * Metric to Azure envelope parsing.
 * @internal
 */
function resourceMetricsToEnvelope(metrics, ikey, isStatsbeat) {
    let envelopes = [];
    const time = new Date();
    const instrumentationKey = ikey;
    const tags = createTagsFromResource(metrics.resource);
    let envelopeName;
    if (isStatsbeat) {
        envelopeName = "Microsoft.ApplicationInsights.Statsbeat";
    }
    else {
        envelopeName = "Microsoft.ApplicationInsights.Metric";
    }
    metrics.scopeMetrics.forEach((scopeMetric) => {
        scopeMetric.metrics.forEach((metric) => {
            metric.dataPoints.forEach((dataPoint) => {
                let baseData = {
                    metrics: [],
                    version: 2,
                    properties: {},
                };
                baseData.properties = createPropertiesFromMetricAttributes(dataPoint.attributes);
                var metricDataPoint = {
                    name: metric.descriptor.name,
                    value: 0,
                    dataPointType: "Aggregation",
                };
                if (metric.dataPointType == sdkMetrics.DataPointType.SUM ||
                    metric.dataPointType == sdkMetrics.DataPointType.GAUGE) {
                    metricDataPoint.value = dataPoint.value;
                    metricDataPoint.count = 1;
                }
                else {
                    metricDataPoint.value = dataPoint.value.sum || 0;
                    metricDataPoint.count = dataPoint.value.count;
                    metricDataPoint.max = dataPoint.value.max;
                    metricDataPoint.min = dataPoint.value.min;
                }
                baseData.metrics.push(metricDataPoint);
                let envelope = {
                    name: envelopeName,
                    time: time,
                    sampleRate: 100,
                    instrumentationKey: instrumentationKey,
                    tags: tags,
                    version: 1,
                    data: {
                        baseType: "MetricData",
                        baseData: Object.assign({}, baseData),
                    },
                };
                envelopes.push(envelope);
            });
        });
    });
    return envelopes;
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Metric Exporter.
 */
class AzureMonitorMetricExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorMetricExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Flag to determine if Exporter is shutdown.
         */
        this._isShutdown = false;
        api.diag.debug("AzureMonitorMetricExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry resource metrics.
     * @param metrics - Resource metrics to export.
     * @param resultCallback - Result callback.
     */
    async export(metrics, resultCallback) {
        if (this._isShutdown) {
            api.diag.info("Exporter shut down. Failed to export spans.");
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        api.diag.info(`Exporting ${metrics.scopeMetrics.length} metrics(s). Converting to envelopes...`);
        let envelopes = resourceMetricsToEnvelope(metrics, this._instrumentationKey);
        // Supress tracing until OpenTelemetry Metrics SDK support it
        api.context.with(core.suppressTracing(api.context.active()), async () => {
            resultCallback(await this._exportEnvelopes(envelopes));
        });
    }
    /**
     * Shutdown AzureMonitorMetricExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        api.diag.info("AzureMonitorMetricExporter shutting down");
        return this._shutdown();
    }
    /**
     * Select aggregation temporality
     */
    selectAggregationTemporality(_instrumentType) {
        if (_instrumentType == sdkMetrics.InstrumentType.UP_DOWN_COUNTER ||
            _instrumentType == sdkMetrics.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER) {
            return sdkMetrics.AggregationTemporality.CUMULATIVE;
        }
        return sdkMetrics.AggregationTemporality.DELTA;
    }
    /**
     * Force flush
     */
    async forceFlush() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Log to Azure envelope parsing.
 * @internal
 */
function logToEnvelope(log, ikey) {
    const time = log.hrTime ? new Date(core.hrTimeToMilliseconds(log.hrTime)) : new Date();
    let sampleRate = 100;
    const instrumentationKey = ikey;
    const tags = createTagsFromLog(log);
    const [properties, measurements] = createPropertiesFromLog(log);
    let name;
    let baseType;
    let baseData;
    if (!log.attributes[ApplicationInsightsBaseType]) {
        // Get Exception attributes if available
        let exceptionType = log.attributes[semanticConventions.SemanticAttributes.EXCEPTION_TYPE];
        if (exceptionType) {
            let exceptionMessage = log.attributes[semanticConventions.SemanticAttributes.EXCEPTION_MESSAGE];
            let exceptionStacktrace = log.attributes[semanticConventions.SemanticAttributes.EXCEPTION_STACKTRACE];
            name = ApplicationInsightsExceptionName;
            baseType = ApplicationInsightsExceptionBaseType;
            let exceptionDetails = {
                typeName: String(exceptionType),
                message: String(exceptionMessage),
                hasFullStack: exceptionStacktrace ? true : false,
                stack: String(exceptionStacktrace),
            };
            const exceptionData = {
                exceptions: [exceptionDetails],
                severityLevel: String(getSeverity(log.severityNumber)),
                version: 2,
            };
            baseData = exceptionData;
        }
        else {
            name = ApplicationInsightsMessageName;
            baseType = ApplicationInsightsMessageBaseType;
            const messageData = {
                message: String(log.body),
                severityLevel: String(getSeverity(log.severityNumber)),
                version: 2,
            };
            baseData = messageData;
        }
    }
    else {
        // If Legacy Application Insights Log
        baseType = String(log.attributes[ApplicationInsightsBaseType]);
        name = getLegacyApplicationInsightsName(log);
        baseData = getLegacyApplicationInsightsBaseData(log);
        if (!baseData) {
            // Failed to parse log
            return;
        }
    }
    return {
        name,
        sampleRate,
        time,
        instrumentationKey,
        tags,
        version: 1,
        data: {
            baseType,
            baseData: Object.assign(Object.assign({}, baseData), { properties,
                measurements }),
        },
    };
}
function createTagsFromLog(log) {
    var _a, _b;
    const tags = createTagsFromResource(log.resource);
    if ((_a = log.spanContext) === null || _a === void 0 ? void 0 : _a.traceId) {
        tags[KnownContextTagKeys.AiOperationId] = log.spanContext.traceId;
    }
    if ((_b = log.spanContext) === null || _b === void 0 ? void 0 : _b.spanId) {
        tags[KnownContextTagKeys.AiOperationParentId] = log.spanContext.spanId;
    }
    return tags;
}
function createPropertiesFromLog(log) {
    const measurements = {};
    const properties = {};
    if (log.attributes) {
        for (const key of Object.keys(log.attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key == semanticConventions.SemanticAttributes.EXCEPTION_TYPE ||
                key == semanticConventions.SemanticAttributes.EXCEPTION_MESSAGE ||
                key == semanticConventions.SemanticAttributes.EXCEPTION_STACKTRACE)) {
                properties[key] = log.attributes[key];
            }
        }
    }
    return [properties, measurements];
}
// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-severitynumber
function getSeverity(severityNumber) {
    if (severityNumber) {
        if (severityNumber > 0 && severityNumber < 9) {
            return KnownSeverityLevel.Verbose;
        }
        else if (severityNumber >= 9 && severityNumber < 13) {
            return KnownSeverityLevel.Information;
        }
        else if (severityNumber >= 13 && severityNumber < 17) {
            return KnownSeverityLevel.Warning;
        }
        else if (severityNumber >= 17 && severityNumber < 21) {
            return KnownSeverityLevel.Error;
        }
        else if (severityNumber >= 21 && severityNumber < 25) {
            return KnownSeverityLevel.Critical;
        }
    }
    return;
}
function getLegacyApplicationInsightsName(log) {
    let name = "";
    switch (log.attributes[ApplicationInsightsBaseType]) {
        case ApplicationInsightsAvailabilityBaseType:
            name = ApplicationInsightsAvailabilityName;
            break;
        case ApplicationInsightsExceptionBaseType:
            name = ApplicationInsightsExceptionName;
            break;
        case ApplicationInsightsMessageBaseType:
            name = ApplicationInsightsMessageName;
            break;
        case ApplicationInsightsPageViewBaseType:
            name = ApplicationInsightsPageViewName;
            break;
        case ApplicationInsightsEventBaseType:
            name = ApplicationInsightsEventName;
            break;
    }
    return name;
}
function getLegacyApplicationInsightsBaseData(log) {
    let baseData = {
        version: 2,
    };
    if (log.body) {
        try {
            switch (log.attributes[ApplicationInsightsBaseType]) {
                case ApplicationInsightsAvailabilityBaseType:
                    baseData = JSON.parse(log.body);
                    break;
                case ApplicationInsightsExceptionBaseType:
                    baseData = JSON.parse(log.body);
                    break;
                case ApplicationInsightsMessageBaseType:
                    baseData = JSON.parse(log.body);
                    break;
                case ApplicationInsightsPageViewBaseType:
                    baseData = JSON.parse(log.body);
                    break;
                case ApplicationInsightsEventBaseType:
                    baseData = JSON.parse(log.body);
                    break;
            }
        }
        catch (err) {
            api.diag.error("AzureMonitorLogExporter failed to parse Application Insights Telemetry");
        }
    }
    return baseData;
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Log Exporter.
 */
class AzureMonitorLogExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorLogExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Flag to determine if Exporter is shutdown.
         */
        this._isShutdown = false;
        api.diag.debug("AzureMonitorLogExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry logs.
     * @param logs - Logs to export.
     * @param resultCallback - Result callback.
     */
    async export(logs, resultCallback) {
        if (this._isShutdown) {
            api.diag.info("Exporter shut down. Failed to export spans.");
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        api.diag.info(`Exporting ${logs.length} logs(s). Converting to envelopes...`);
        let envelopes = [];
        logs.forEach((log) => {
            let envelope = logToEnvelope(log, this._instrumentationKey);
            if (envelope) {
                envelopes.push(envelope);
            }
        });
        resultCallback(await this._exportEnvelopes(envelopes));
    }
    /**
     * Shutdown AzureMonitorLogExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        api.diag.info("AzureMonitorLogExporter shutting down");
        return this._shutdown();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor Statsbeat Exporter
 */
class AzureMonitorStatsbeatExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorStatsbeatExporter class.
     * @param options - Exporter configuration
     */
    constructor(options) {
        super(options, true);
        /**
         * Flag to determine if the Exporter is shutdown.
         */
        this._isShutdown = false;
    }
    /**
     * Export Statsbeat metrics.
     */
    async export(metrics, resultCallback) {
        if (this._isShutdown) {
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        let envelopes = resourceMetricsToEnvelope(metrics, this._instrumentationKey, true // isStatsbeat flag passed to create a Statsbeat envelope.
        );
        // Supress tracing until OpenTelemetry Metrics SDK support it
        api.context.with(core.suppressTracing(api.context.active()), async () => {
            resultCallback(await this._exportEnvelopes(envelopes));
        });
    }
    /**
     * Shutdown AzureMonitorStatsbeatExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        return this._shutdown();
    }
    /**
     * Force flush.
     */
    async forceFlush() {
        return Promise.resolve();
    }
}

exports.ApplicationInsightsSampler = ApplicationInsightsSampler;
exports.AzureMonitorBaseExporter = AzureMonitorBaseExporter;
exports.AzureMonitorLogExporter = AzureMonitorLogExporter;
exports.AzureMonitorMetricExporter = AzureMonitorMetricExporter;
exports.AzureMonitorStatsbeatExporter = AzureMonitorStatsbeatExporter;
exports.AzureMonitorTraceExporter = AzureMonitorTraceExporter;
//# sourceMappingURL=index.js.map
