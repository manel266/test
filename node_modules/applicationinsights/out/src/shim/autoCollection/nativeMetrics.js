"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeMetrics = void 0;
const monitor_opentelemetry_exporter_1 = require("@azure/monitor-opentelemetry-exporter");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const logging_1 = require("../logging");
/**
 * Azure Monitor Native Metrics
 * @internal
 */
class NativeMetrics {
    /**
     * Initializes a new instance of the NativeMetrics class.
     * @param options - Distro configuration.
     * @param config - Native Metrics extra configuration.
     */
    constructor(options, config) {
        this._collectionInterval = 60000; // 60 seconds
        this._options = options;
        const meterProviderConfig = {
            resource: this._options.resource,
        };
        this._meterProvider = new sdk_metrics_1.MeterProvider(meterProviderConfig);
        this._azureExporter = new monitor_opentelemetry_exporter_1.AzureMonitorMetricExporter(this._options.azureMonitorExporterConfig);
        const metricReaderOptions = {
            exporter: this._azureExporter,
            exportIntervalMillis: (config === null || config === void 0 ? void 0 : config.collectionInterval) || this._collectionInterval,
        };
        this._metricReader = new sdk_metrics_1.PeriodicExportingMetricReader(metricReaderOptions);
        this._meterProvider.addMetricReader(this._metricReader);
        this._meter = this._meterProvider.getMeter("AzureMonitorNativeMetricsMeter");
        this._eventLoopHistogram = this._meter.createHistogram("Event Loop CPU Time");
        this._garbageCollectionScavenge = this._meter.createHistogram("Scavenge Garbage Collection Duration");
        this._garbageCollectionMarkSweepCompact = this._meter.createHistogram("MarkSweepCompact Garbage Collection Duration");
        this._garbageCollectionIncrementalMarking = this._meter.createHistogram("IncrementalMarking Collection Duration");
        this._heapMemoryTotalGauge = this._meter.createObservableGauge("Memory Total (Heap)");
        this._heapMemoryUsageGauge = this._meter.createObservableGauge("Memory Usage (Heap)");
        this._memoryUsageNonHeapGauge = this._meter.createObservableGauge("Memory Usage (Non-Heap)");
        this._initialize();
    }
    /**
     * Shutdown Meter Provider it will return no-op Meters after being called.
     */
    shutdown() {
        this._meterProvider.shutdown();
    }
    /**
     * Force flush Meter Provider.
     */
    async flush() {
        await this._meterProvider.forceFlush();
    }
    _initialize() {
        // Try to require in the native-metrics library. If it's found initialize it, else do nothing and never try again.
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const NativeMetricsEmitter = require("applicationinsights-native-metrics");
            this._emitter = new NativeMetricsEmitter();
            logging_1.Logger.getInstance().info("Native metrics module successfully loaded!");
        }
        catch (err) {
            // Package not available
            return;
        }
        // Enable the emitter if we were able to construct one
        if (this._emitter) {
            try {
                // enable self
                this._emitter.enable(true, this._collectionInterval);
            }
            catch (err) {
                logging_1.Logger.getInstance().error("Native metrics enable failed", err);
            }
            // Add histogram data collection
            this._handle = setInterval(() => this._collectHistogramData(), this._collectionInterval);
            this._handle.unref();
            // Add observable callbacks
            this._heapMemoryTotalGauge.addCallback(this._getHeapTotal.bind(this));
            this._heapMemoryUsageGauge.addCallback(this._getHeapUsage.bind(this));
            this._memoryUsageNonHeapGauge.addCallback(this._getNonHeapUsage.bind(this));
        }
    }
    _getHeapUsage(observableResult) {
        const memoryUsage = process.memoryUsage();
        const { heapUsed } = memoryUsage;
        observableResult.observe(heapUsed);
    }
    _getHeapTotal(observableResult) {
        const memoryUsage = process.memoryUsage();
        const { heapTotal } = memoryUsage;
        observableResult.observe(heapTotal);
    }
    _getNonHeapUsage(observableResult) {
        const memoryUsage = process.memoryUsage();
        const { heapTotal, rss } = memoryUsage;
        observableResult.observe(rss - heapTotal);
    }
    _collectHistogramData() {
        this._getEventLoopCpu();
        this._getGarbageCollection();
    }
    _getEventLoopCpu() {
        try {
            const loopData = this._emitter.getLoopData();
            const metrics = loopData.loopUsage;
            if (metrics.count === 0) {
                return;
            }
            this._eventLoopHistogram.record(metrics.total);
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Native metrics failed to get event loop CPU", err);
        }
    }
    _getGarbageCollection() {
        try {
            const gcData = this._emitter.getGCData();
            for (const gc in gcData) {
                const metrics = gcData[gc].metrics;
                switch (gc) {
                    case "IncrementalMarking":
                        this._garbageCollectionIncrementalMarking.record(metrics.total);
                        break;
                    case "MarkSweepCompact":
                        this._garbageCollectionMarkSweepCompact.record(metrics.total);
                        break;
                    case "Scavenge":
                        this._garbageCollectionScavenge.record(metrics.total);
                        break;
                }
            }
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Native metrics failed to get event Garbage Collection metrics", err);
        }
    }
}
exports.NativeMetrics = NativeMetrics;
//# sourceMappingURL=nativeMetrics.js.map