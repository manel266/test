"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryClient = void 0;
const monitor_opentelemetry_1 = require("@azure/monitor-opentelemetry");
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const generated_1 = require("../declarations/generated");
const context_1 = require("./context");
const logging_1 = require("./logging");
const util_1 = require("./util");
const console_1 = require("./autoCollection/console");
const exceptions_1 = require("./autoCollection/exceptions");
const internal_1 = require("./configuration/internal");
/**
 * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and
 * and manually trigger immediate sending (flushing)
 */
class TelemetryClient {
    /**
     * Constructs a new client of the client
     * @param setupString the Connection String or Instrumentation Key to use (read from environment variable if not specified)
     */
    constructor(input) {
        this.commonProperties = {};
        this.context = new context_1.Context();
        if (input) {
            if (typeof (input) === "object") {
                this._options = input;
            }
            else {
                // TODO: Add Support for iKey as well
                this._options = {
                    azureMonitorExporterConfig: {
                        connectionString: input
                    }
                };
            }
        }
        // Internal config with extra configuration not available in Azure Monitor Distro
        this._internalConfig = new internal_1.InternalConfig(this._options);
        this._client = new monitor_opentelemetry_1.AzureMonitorOpenTelemetryClient(this._options);
        this._console = new console_1.AutoCollectConsole(this);
        if (this._internalConfig.enableAutoCollectExceptions) {
            this._exceptions = new exceptions_1.AutoCollectExceptions(this);
        }
        this._idGenerator = new sdk_trace_base_1.RandomIdGenerator();
        this._console.enable(this._internalConfig.logInstrumentations);
    }
    getAzureMonitorOpenTelemetryClient() {
        return this._client;
    }
    getInternalConfig() {
        return this._internalConfig;
    }
    /**
     * Log information about availability of an application
     * @param telemetry      Object encapsulating tracking options
     */
    trackAvailability(telemetry) {
        try {
            const logRecord = this._availabilityToLogRecord(telemetry);
            this._client.getLogger().emit(logRecord);
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a page view
     * @param telemetry      Object encapsulating tracking options
     */
    trackPageView(telemetry) {
        try {
            const logRecord = this._pageViewToLogRecord(telemetry);
            this._client.getLogger().emit(logRecord);
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a trace message
     * @param telemetry      Object encapsulating tracking options
     */
    trackTrace(telemetry) {
        try {
            const logRecord = this._traceToLogRecord(telemetry);
            this._client.getLogger().emit(logRecord);
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log an exception
     * @param telemetry      Object encapsulating tracking options
     */
    trackException(telemetry) {
        if (telemetry && telemetry.exception && !util_1.Util.getInstance().isError(telemetry.exception)) {
            telemetry.exception = new Error(telemetry.exception.toString());
        }
        try {
            const logRecord = this._exceptionToLogRecord(telemetry);
            this._client.getLogger().emit(logRecord);
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a user action or other occurrence.
     * @param telemetry      Object encapsulating tracking options
     */
    trackEvent(telemetry) {
        try {
            const logRecord = this._eventToLogRecord(telemetry);
            this._client.getLogger().emit(logRecord);
        }
        catch (err) {
            logging_1.Logger.getInstance().error("Failed to send telemetry.", err);
        }
    }
    /**
     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.
     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the
     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.
     * @param telemetry      Object encapsulating tracking options
     */
    trackMetric(telemetry) {
        // TODO : Create custom metric
        // let meter = this.client.getMetricHandler().getCustomMetricsHandler().getMeter();
        // let metricName = "";
        // let options: MetricOptions = {};
        // meter.createHistogram(metricName, options)
    }
    /**
     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests
     * that aren't automatically captured or if you've disabled automatic request collection.
     *
     * @param telemetry      Object encapsulating tracking options
     */
    trackRequest(telemetry) {
        const startTime = telemetry.time || new Date();
        const endTime = startTime.getTime() + telemetry.duration;
        // TODO: Change resourceManager if ID is provided?
        const ctx = api_1.context.active();
        const attributes = Object.assign({}, telemetry.properties);
        attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD] = "HTTP";
        attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL] = telemetry.url;
        attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE] = telemetry.resultCode;
        const options = {
            kind: api_1.SpanKind.SERVER,
            attributes: attributes,
            startTime: startTime,
        };
        const span = this._client
            .getTracer()
            .startSpan(telemetry.name, options, ctx);
        span.setStatus({
            code: telemetry.success ? api_1.SpanStatusCode.OK : api_1.SpanStatusCode.ERROR,
        });
        span.end(endTime);
    }
    /**
     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies
     * that aren't automatically captured or if you've disabled automatic dependency collection.
     *
     * @param telemetry      Object encapsulating tracking option
     * */
    trackDependency(telemetry) {
        const startTime = telemetry.time || new Date();
        const endTime = startTime.getTime() + telemetry.duration;
        if (telemetry && !telemetry.target && telemetry.data) {
            // url.parse().host returns null for non-urls,
            // making this essentially a no-op in those cases
            // If this logic is moved, update jsdoc in DependencyTelemetry.target
            // url.parse() is deprecated, update to use WHATWG URL API instead
            try {
                telemetry.target = new URL(telemetry.data).host;
            }
            catch (error) {
                // set target as null to be compliant with previous behavior
                telemetry.target = null;
                logging_1.Logger.getInstance().warn(this.constructor.name, "Failed to create URL.", error);
            }
        }
        const ctx = api_1.context.active();
        const attributes = Object.assign({}, telemetry.properties);
        if (telemetry.dependencyTypeName) {
            if (telemetry.dependencyTypeName.toLowerCase().indexOf("http") > -1) {
                attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD] = "HTTP"; // TODO: Dependency doesn't expose method in any property
                attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL] = telemetry.data;
                attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE] = telemetry.resultCode;
            }
            else if (util_1.Util.getInstance().isDbDependency(telemetry.dependencyTypeName)) {
                attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM] = telemetry.dependencyTypeName;
                attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT] = telemetry.data;
            }
        }
        if (telemetry.target) {
            attributes[semantic_conventions_1.SemanticAttributes.PEER_SERVICE] = telemetry.target;
        }
        const options = {
            kind: api_1.SpanKind.CLIENT,
            attributes: attributes,
            startTime: startTime,
        };
        const span = this._client
            .getTracer()
            .startSpan(telemetry.name, options, ctx);
        span.setStatus({
            code: telemetry.success ? api_1.SpanStatusCode.OK : api_1.SpanStatusCode.ERROR,
        });
        span.end(endTime);
    }
    /**
     * Immediately send all queued telemetry.
     */
    async flush() {
        this._client.flush();
    }
    /**
     * Shutdown client
     */
    async shutdown() {
        var _a;
        this._client.shutdown();
        this._console.shutdown();
        this._console = null;
        (_a = this._exceptions) === null || _a === void 0 ? void 0 : _a.shutdown();
        this._exceptions = null;
    }
    /**
     * Generic track method for all telemetry types
     * @param data the telemetry to send
     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes
     */
    track(telemetry, telemetryType) {
        throw new Error("Not implemented");
    }
    /**
     * Automatically populate telemetry properties like RoleName when running in Azure
     *
     * @param value if true properties will be populated
     */
    setAutoPopulateAzureProperties() {
        // TODO: Config is only used during initialization of ResourceManager so it cannot be set after.
    }
    /*
     * Get Statsbeat instance
     */
    getStatsbeat() {
        return null;
    }
    setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk) {
        throw new Error("Not implemented");
    }
    /**
     * Adds telemetry processor to the collection. Telemetry processors will be called one by one
     * before telemetry item is pushed for sending and in the order they were added.
     *
     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean
     */
    addTelemetryProcessor(telemetryProcessor) {
        throw new Error("Not implemented");
    }
    /*
     * Removes all telemetry processors
     */
    clearTelemetryProcessors() {
        throw new Error("Not implemented");
    }
    _telemetryToLogRecord(telemetry, baseType, baseData) {
        try {
            const attributes = Object.assign({}, telemetry.properties);
            const record = { attributes: attributes, body: util_1.Util.getInstance().stringify(baseData) };
            record.attributes["_MS.baseType"] = baseType;
            return record;
        }
        catch (err) {
            logging_1.Logger.getInstance().warn("Failed to convert telemetry event to Log Record.", err);
        }
    }
    /**
     * Availability Log to LogRecord parsing.
     * @internal
     */
    _availabilityToLogRecord(telemetry) {
        const baseType = "AvailabilityData";
        const baseData = {
            id: telemetry.id || this._idGenerator.generateSpanId(),
            name: telemetry.name,
            duration: util_1.Util.getInstance().msToTimeSpan(telemetry.duration),
            success: telemetry.success,
            runLocation: telemetry.runLocation,
            message: telemetry.message,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * Exception to LogRecord parsing.
     * @internal
     */
    _exceptionToLogRecord(telemetry) {
        const baseType = "ExceptionData";
        const stack = telemetry.exception["stack"];
        const parsedStack = (0, exceptions_1.parseStack)(stack);
        const exceptionDetails = {
            message: telemetry.exception.message,
            typeName: telemetry.exception.name,
            parsedStack: parsedStack,
            hasFullStack: util_1.Util.getInstance().isArray(parsedStack) && parsedStack.length > 0,
        };
        const baseData = {
            severityLevel: telemetry.severity || generated_1.KnownSeverityLevel.Error,
            exceptions: [exceptionDetails],
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * Trace to LogRecord parsing.
     * @internal
     */
    _traceToLogRecord(telemetry) {
        const baseType = "MessageData";
        const baseData = {
            message: telemetry.message,
            severityLevel: telemetry.severity || generated_1.KnownSeverityLevel.Information,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * PageView to LogRecord parsing.
     * @internal
     */
    _pageViewToLogRecord(telemetry) {
        const baseType = "PageViewData";
        const baseData = {
            id: telemetry.id || this._idGenerator.generateSpanId(),
            name: telemetry.name,
            duration: util_1.Util.getInstance().msToTimeSpan(telemetry.duration),
            url: telemetry.url,
            referredUri: telemetry.referredUri,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
    /**
     * Event to LogRecord parsing.
     * @internal
     */
    _eventToLogRecord(telemetry) {
        const baseType = "EventData";
        const baseData = {
            name: telemetry.name,
            measurements: telemetry.measurements,
            version: 2,
        };
        const record = this._telemetryToLogRecord(telemetry, baseType, baseData);
        return record;
    }
}
exports.TelemetryClient = TelemetryClient;
//# sourceMappingURL=telemetryClient.js.map