"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalAzureLogger = void 0;
const fs = require("fs");
const os = require("os");
const path = require("path");
const util_1 = require("../util");
class InternalAzureLogger {
    constructor() {
        this._TAG = "InternalLogger:";
        this._cleanupTimeOut = 60 * 30 * 1000; // 30 minutes;
        this._fileCleanupTimer = null;
        this._logToFile = false;
        this._logToConsole = true;
        const logDestination = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION; // destination can be one of file, console or file+console
        if (logDestination === "file+console") {
            this._logToFile = true;
        }
        if (logDestination === "file") {
            this._logToFile = true;
            this._logToConsole = false;
        }
        this._maxSizeBytes = 50000;
        this._maxHistory = 1;
        this._logFileName = "applicationinsights.log";
        // If custom path not provided use temp folder, /tmp for *nix and USERDIR/AppData/Local/Temp for Windows
        const logFilePath = process.env.APPLICATIONINSIGHTS_LOGDIR;
        if (!logFilePath) {
            this._tempDir = path.join(os.tmpdir(), "appInsights-node");
        }
        else {
            if (path.isAbsolute(logFilePath)) {
                this._tempDir = logFilePath;
            }
            else {
                this._tempDir = path.join(process.cwd(), logFilePath);
            }
        }
        this._fileFullPath = path.join(this._tempDir, this._logFileName);
        this._backUpNameFormat = `.${this._logFileName}`; // {currentime}.applicationinsights.log
        if (this._logToFile) {
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setInterval(() => {
                    this._fileCleanupTask();
                }, this._cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    async logMessage(message, ...optionalParams) {
        try {
            const args = message ? [message, ...optionalParams] : optionalParams;
            if (this._logToFile) {
                await this._storeToDisk(args);
            }
            if (this._logToConsole) {
                // eslint-disable-next-line no-console
                console.log(...args);
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to log to file: ${err && err.message}`);
        }
    }
    async _storeToDisk(args) {
        const data = `${args}\r\n`;
        try {
            await (0, util_1.confirmDirExists)(this._tempDir);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to create directory for log file: ${err && err.message}`);
            return;
        }
        try {
            await (0, util_1.accessAsync)(this._fileFullPath, fs.constants.F_OK);
        }
        catch (err) {
            // No file create one
            try {
                await (0, util_1.appendFileAsync)(this._fileFullPath, data);
            }
            catch (appendError) {
                // eslint-disable-next-line no-console
                console.log(this._TAG, `Failed to put log into file: ${appendError && appendError.message}`);
                return;
            }
        }
        // Check size
        const size = await (0, util_1.getShallowFileSize)(this._fileFullPath);
        if (size > this._maxSizeBytes) {
            await this._createBackupFile(data);
        }
        else {
            await (0, util_1.appendFileAsync)(this._fileFullPath, data);
        }
    }
    async _createBackupFile(data) {
        try {
            const buffer = await (0, util_1.readFileAsync)(this._fileFullPath);
            const backupPath = path.join(this._tempDir, `${new Date().getTime()}.${this._logFileName}`);
            await (0, util_1.writeFileAsync)(backupPath, buffer);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log("Failed to generate backup log file", err);
        }
        finally {
            // Store logs
            (0, util_1.writeFileAsync)(this._fileFullPath, data);
        }
    }
    async _fileCleanupTask() {
        try {
            let files = await (0, util_1.readdirAsync)(this._tempDir);
            // Filter only backup files
            files = files.filter((f) => path.basename(f).indexOf(this._backUpNameFormat) > -1);
            // Sort by creation date
            files.sort((a, b) => {
                // Check expiration
                const aCreationDate = new Date(parseInt(a.split(this._backUpNameFormat)[0]));
                const bCreationDate = new Date(parseInt(b.split(this._backUpNameFormat)[0]));
                if (aCreationDate < bCreationDate) {
                    return -1;
                }
                if (aCreationDate >= bCreationDate) {
                    return 1;
                }
            });
            const totalFiles = files.length;
            for (let i = 0; i < totalFiles - this._maxHistory; i++) {
                const pathToDelete = path.join(this._tempDir, files[i]);
                await (0, util_1.unlinkAsync)(pathToDelete);
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.log(this._TAG, `Failed to cleanup log files: ${err && err.message}`);
        }
    }
}
exports.InternalAzureLogger = InternalAzureLogger;
//# sourceMappingURL=internalAzureLogger.js.map